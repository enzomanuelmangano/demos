{
  "animation_name": "Record Button",
  "animation_slug": "record-button",
  "description": "A scroll-triggered animated button that reveals with custom Skia path animations. Features dual-line path drawing synchronized with scroll progress, dynamic text color transitions, activation feedback with haptics, and snap-to-scroll behavior. The button smoothly morphs from invisible to a fully outlined 'Record' button with rounded corners as the user scrolls up.",
  "main_features": [
    "Scroll-based path animation reveal",
    "Custom Skia path drawing with mirrored symmetry",
    "Inverted FlatList with snap-to-interval scrolling",
    "Progress-driven text opacity and color transitions",
    "Activation state with scale animation and haptic feedback",
    "Dynamic border radius interpolation on main screen",
    "Dual-path rendering (left and right lines) with synchronized progress",
    "Button reset on press with smooth scroll-to-index",
    "Smart snapping behavior based on scroll threshold",
    "Custom rounded rectangle reveal on full activation"
  ],
  "file_structure": {
    "index.tsx": "Main demo component with inverted FlatList and scroll logic",
    "components/record-button/index.tsx": "Core RecordButton component with Skia canvas and animations",
    "components/record-button/create-skia-line.ts": "Utility for generating custom Skia path with rounded corners",
    "utils/haptics.ts": "Haptic feedback wrapper using expo-haptics"
  },
  "core_technologies": {
    "animations": "react-native-reanimated",
    "graphics": "@shopify/react-native-skia",
    "interactions": "pressto",
    "haptics": "expo-haptics",
    "threading": "react-native-worklets"
  },
  "packages_and_versions": {
    "react-native-reanimated": {
      "version": "~4.1.1",
      "hooks": [
        "useSharedValue",
        "useAnimatedStyle",
        "useDerivedValue",
        "useScrollViewOffset",
        "useAnimatedRef",
        "useAnimatedReaction"
      ],
      "functions": [
        "withSpring",
        "withTiming",
        "interpolate"
      ],
      "components": [
        "Animated.FlatList",
        "Animated.View",
        "Animated.Text"
      ],
      "critical_feature": "useScrollViewOffset for tracking scroll position and useDerivedValue for progress calculation"
    },
    "@shopify/react-native-skia": {
      "version": "2.2.12",
      "components": [
        "Canvas",
        "Path",
        "RoundedRect"
      ],
      "utilities": [
        "Skia.Path.Make()",
        "Skia.Matrix()"
      ],
      "methods": [
        "moveTo",
        "lineTo",
        "rArcTo",
        "addPath",
        "transform"
      ],
      "usage": "Custom path drawing for button outline animation"
    },
    "react-native-worklets": {
      "version": "0.5.1",
      "imports": [
        "scheduleOnRN"
      ],
      "usage": "Bridge worklet to JS thread for haptic feedback"
    },
    "pressto": {
      "version": "0.3.5-beta.1",
      "component": "PressableScale",
      "usage": "Button press interaction with scale feedback"
    },
    "expo-haptics": {
      "version": "~15.0.7",
      "imports": [
        "ImpactFeedbackStyle"
      ],
      "functions": [
        "impactAsync"
      ],
      "usage": "Haptic feedback on button activation"
    }
  },
  "animation_techniques": {
    "scroll_driven_animation": {
      "hook": "useScrollViewOffset",
      "source": "scrollRef (inverted FlatList)",
      "progress_calculation": {
        "input_range": "[WindowHeight * 0.08, WindowHeight * 0.2]",
        "output_range": "[0, 1]",
        "extrapolation": "CLAMP",
        "usage": "Drives path drawing and text opacity"
      },
      "effect": "Button reveals as user scrolls from bottom screen to top"
    },
    "path_drawing_animation": {
      "technique": "Skia Path with 'end' prop driven by progress",
      "paths": "Two mirrored paths (left and right)",
      "end_value": "progress.value (0 to 1)",
      "effect": "Lines draw from center outward, revealing button outline",
      "stroke_properties": {
        "strokeWidth": 1,
        "strokeCap": "round",
        "style": "stroke"
      }
    },
    "path_mirroring": {
      "technique": "Matrix transformation for left path",
      "transformation": "Skia.Matrix().translate(width, 0).scale(-1, 1)",
      "base": "rightLinePath",
      "effect": "Creates symmetric left path without duplicating path logic",
      "benefit": "DRY principle - define path once, mirror for symmetry"
    },
    "activation_animation": {
      "trigger": "progress.value > 0.98",
      "shared_value": "activated (useDerivedValue)",
      "scale_animation": "withSpring(!activated ? 1 : 1.1)",
      "text_properties": {
        "color": "activated ? 'white' : color",
        "fontWeight": "activated ? '600' : '500'"
      },
      "background": "RoundedRect opacity withTiming(activated ? 1 : 0)",
      "haptic": "useAnimatedReaction triggers haptic on activation"
    },
    "border_radius_interpolation": {
      "location": "Main screen (HomeScreen)",
      "input_range": "[0, 0.1]",
      "output_range": "[0, 35]",
      "property": "borderRadius + borderCurve: 'continuous'",
      "effect": "Screen corners round as user begins scrolling",
      "extrapolation": "CLAMP"
    },
    "snap_to_scroll": {
      "snapToInterval": "WindowHeight",
      "decelerationRate": "fast",
      "custom_snapping": {
        "onScrollBeginDrag": "Records if progress < 0.9 (shouldEnableSnapping)",
        "onScrollEndDrag": "If progress > 0.97 && shouldEnableSnapping, scrolls to index 1",
        "effect": "Smart snapping only when scrolling from below, not from above"
      },
      "note": "Custom logic mimics original app behavior"
    },
    "text_animation": {
      "opacity": "progress.value",
      "color": "activated ? 'white' : color",
      "fontWeight": "activated ? '600' : '500'",
      "effect": "Text fades in as paths draw, then changes to white on activation"
    }
  },
  "reanimated_patterns": {
    "shared_values": [
      {
        "name": "scrollOffset",
        "source": "useScrollViewOffset(scrollRef)",
        "type": "number",
        "usage": "Tracks inverted FlatList scroll position",
        "drives": "progress calculation and border radius interpolation"
      },
      {
        "name": "shouldEnableSnapping",
        "type": "boolean",
        "initial": false,
        "usage": "Controls conditional snapping behavior",
        "updated": "onScrollBeginDrag based on progress value"
      }
    ],
    "useDerivedValue": {
      "usage_count": 2,
      "instances": [
        {
          "name": "progress",
          "calculation": "interpolate(scrollOffset.value, [WindowHeight * 0.08, WindowHeight * 0.2], [0, 1], CLAMP)",
          "purpose": "Normalize scroll offset to 0-1 range for animations",
          "dependencies": [
            "scrollOffset.value"
          ]
        },
        {
          "name": "activated",
          "calculation": "progress.value > 0.98",
          "purpose": "Boolean state for button activation",
          "dependencies": [
            "progress.value"
          ]
        },
        {
          "name": "internalRoundedRectOpacity",
          "calculation": "withTiming(activated.value ? 1 : 0)",
          "purpose": "Smooth opacity transition for filled background",
          "dependencies": [
            "activated.value"
          ]
        }
      ]
    },
    "useAnimatedStyle": {
      "usage_count": 3,
      "instances": [
        {
          "name": "rMainPageStyle",
          "location": "Main screen (HomeScreen)",
          "animated_properties": [
            "borderRadius"
          ],
          "interpolation": "scrollOffset 0->0.1 maps to borderRadius 0->35",
          "effect": "Screen corners round on scroll start"
        },
        {
          "name": "rContainerStyle",
          "location": "RecordButton component",
          "animated_properties": [
            "transform.scale"
          ],
          "animation": "withSpring scale 1 -> 1.1 on activation",
          "effect": "Button scales up when fully activated"
        },
        {
          "name": "rTextStyle",
          "location": "RecordButton text",
          "animated_properties": [
            "color",
            "opacity",
            "fontWeight"
          ],
          "effect": "Text fades in with progress, changes to white/bold on activation"
        }
      ]
    },
    "useAnimatedReaction": {
      "usage_count": 1,
      "watch": "activated.value",
      "callback": "(currentlyActivated, prevActivated) => if (currentlyActivated && !prevActivated) scheduleOnRN(hapticFeedback)",
      "purpose": "Trigger haptic feedback on activation edge (false -> true)",
      "pattern": "Edge detection for one-time effect on state change"
    },
    "useAnimatedRef": {
      "usage": "FlatList ref for programmatic scrolling",
      "methods_used": [
        "scrollToIndex"
      ],
      "pattern": "Allows calling FlatList methods from both JS and worklet contexts"
    },
    "worklet_callbacks": {
      "onScrollBeginDrag": "Sets shouldEnableSnapping based on progress < 0.9",
      "onScrollEndDrag": "Conditionally scrolls to index 1 if progress > 0.97",
      "note": "Called directly from Animated.FlatList, run on UI thread"
    }
  },
  "skia_patterns": {
    "path_creation": {
      "function": "getRightLinePath",
      "method": "Skia.Path.Make()",
      "commands": [
        "moveTo(realWidth / 2, realHeight) - Start at bottom center",
        "lineTo(realWidth - borderRadius, realHeight) - Line to bottom right",
        "rArcTo(...) - Rounded corner arc (bottom-right)",
        "lineTo(realWidth, borderRadius + internalPadding) - Line up right side",
        "rArcTo(...) - Rounded corner arc (top-right)",
        "lineTo(realWidth / 2, internalPadding) - Line to top center"
      ],
      "key_concepts": [
        "internalPadding = strokeWidth / 2 (accounts for stroke width)",
        "realWidth/realHeight subtract padding for accurate sizing",
        "rArcTo uses relative arc positioning for rounded corners"
      ]
    },
    "path_transformation": {
      "technique": "Matrix transformation for mirroring",
      "steps": [
        "Create new path with Skia.Path.Make()",
        "Add rightLinePath with addPath",
        "Transform with matrix: translate(width, 0).scale(-1, 1)",
        "Result: Mirrored path for left side"
      ],
      "benefit": "Single path definition, transformed for symmetry"
    },
    "canvas_rendering": {
      "component": "Canvas",
      "size": "{ height, width } (matches button dimensions)",
      "position": "absolute",
      "children": [
        "Path (left line) with end={progress}",
        "Path (right line) with end={progress}",
        "RoundedRect (filled background on activation)"
      ],
      "layering": "Paths render first, RoundedRect on top"
    },
    "path_props": {
      "path": "Skia Path object",
      "color": "Button color prop",
      "style": "'stroke'",
      "strokeWidth": "Configurable stroke width",
      "strokeCap": "'round'",
      "end": "progress (0 to 1) - drives drawing animation"
    },
    "rounded_rect": {
      "opacity": "internalRoundedRectOpacity (animated)",
      "x": 0,
      "y": 0,
      "width": "Button width",
      "height": "Button height",
      "r": "borderRadius",
      "strokeWidth": "strokeWidth prop",
      "color": "Button color",
      "effect": "Filled background appears on activation"
    }
  },
  "scroll_interaction_patterns": {
    "inverted_flatlist": {
      "prop": "inverted={true}",
      "effect": "List scrolls bottom-to-top, content rendered upside down",
      "data": "['HomeScreen', 'TopScreen']",
      "purpose": "Creates upward scroll reveal effect"
    },
    "snap_behavior": {
      "snapToInterval": "WindowHeight",
      "decelerationRate": "fast",
      "custom_logic": {
        "onScrollBeginDrag": "shouldEnableSnapping.value = progress.value < 0.9",
        "onScrollEndDrag": "if (progress.value > 0.97 && shouldEnableSnapping) scrollToIndex(1)",
        "reasoning": "Only snap to top screen when scrolling from below, not when already near top"
      }
    },
    "scroll_tracking": {
      "hook": "useScrollViewOffset(scrollRef)",
      "ref_type": "useAnimatedRef<FlatList>",
      "type_cast": "as any (for TypeScript compatibility)",
      "real_time": "Updates every frame during scroll"
    },
    "button_press_action": {
      "handler": "onButtonPress",
      "action": "scrollRef.current?.scrollToIndex({ index: 0 })",
      "effect": "Returns to home screen, resetting animation"
    }
  },
  "component_architecture": {
    "RecordButton_demo": {
      "type": "Demo container with scroll interaction",
      "state": {
        "scrollRef": "useAnimatedRef<FlatList>",
        "scrollOffset": "useScrollViewOffset(scrollRef)",
        "progress": "useDerivedValue (interpolated scroll)",
        "shouldEnableSnapping": "useSharedValue<boolean>"
      },
      "callbacks": [
        "onButtonPress",
        "onScrollBeginDrag",
        "onScrollEndDrag",
        "renderItem"
      ],
      "rendering": "Inverted FlatList with two screens"
    },
    "RecordButtonComponent": {
      "type": "Reusable animated button",
      "props": {
        "width": "number (required)",
        "height": "number (required)",
        "progress": "SharedValue<number> (required)",
        "strokeWidth": "number (optional, default 0)",
        "borderRadius": "number (optional, default 0)",
        "color": "string (required)",
        "onPress": "() => void (optional)",
        "fontSize": "number (optional, default 16)",
        "style": "StyleProp<ViewStyle> (optional)"
      },
      "memo": false,
      "computed_values": [
        "rightLinePath (useMemo)",
        "leftLinePath (useMemo)",
        "activated (useDerivedValue)",
        "basePathProps (useMemo)"
      ]
    },
    "haptics_utility": {
      "function": "hapticFeedback",
      "parameter": "type = Haptics.ImpactFeedbackStyle.Light",
      "implementation": "Haptics.impactAsync(type)",
      "usage": "Called via scheduleOnRN from useAnimatedReaction"
    }
  },
  "layout_and_positioning": {
    "demo_layout": {
      "container": "FlatList with two full-screen items",
      "screen_dimensions": "Dimensions.get('window')",
      "item_height": "WindowHeight",
      "item_width": "WindowWidth"
    },
    "button_positioning": {
      "position": "absolute",
      "bottom": "ButtonHeight (40px)",
      "alignment": "Centered in TopScreen",
      "dimensions": {
        "width": 90,
        "height": 40,
        "borderRadius": 20
      }
    },
    "canvas_overlay": {
      "position": "absolute",
      "size": "Matches button dimensions",
      "z_index": "Above button background, below text"
    },
    "text_positioning": {
      "position": "absolute",
      "alignment": "Center",
      "z_index": "Above canvas and background"
    }
  },
  "visual_design": {
    "color_scheme": {
      "button_color": "#ed4e3c (red/coral)",
      "text_initial": "color (#ed4e3c)",
      "text_activated": "white",
      "home_screen": "#191919 (dark gray)",
      "top_screen": "#252525 (medium gray)"
    },
    "dimensions": {
      "button": {
        "width": 90,
        "height": 40,
        "borderRadius": 20,
        "strokeWidth": 1
      },
      "screens": {
        "width": "Full window width",
        "height": "Full window height"
      }
    },
    "typography": {
      "record_text": {
        "fontSize": 16,
        "color": "Animated (color -> white)",
        "fontWeight": "Animated (500 -> 600)",
        "opacity": "progress.value"
      },
      "scroll_text": {
        "fontSize": 18,
        "color": "white"
      }
    },
    "border_curve": {
      "property": "borderCurve: 'continuous'",
      "platform": "iOS",
      "applied_to": "HomeScreen",
      "effect": "Apple-style squircle corners"
    }
  },
  "performance_optimizations": {
    "useMemo": {
      "rightLinePath": "Path created once, only recalculates on dimension changes",
      "leftLinePath": "Derived from rightLinePath, recalculates when rightLinePath changes",
      "basePathProps": "Path props object memoized to avoid recreating on every render"
    },
    "useCallback": {
      "onButtonPress": "Prevents recreation on every render",
      "renderItem": "Optimizes FlatList rendering",
      "onScrollBeginDrag": "Stable callback reference",
      "onScrollEndDrag": "Stable callback reference"
    },
    "worklet_execution": {
      "pattern": "Scroll callbacks run on UI thread",
      "benefit": "No bridge crossing for scroll events",
      "animations": "All Reanimated animations run on UI thread"
    },
    "flatlist_config": {
      "bounces": false,
      "showsVerticalScrollIndicator": false,
      "overScrollMode": "never",
      "benefit": "Reduces visual noise and improves performance"
    },
    "skia_optimization": {
      "path_reuse": "Paths created once in useMemo",
      "canvas_rendering": "GPU-accelerated via Skia",
      "minimal_redraw": "Only 'end' prop changes, path itself is static"
    }
  },
  "use_cases": {
    "primary": [
      "Scroll-to-reveal UI elements",
      "Story-style vertical scrolling apps",
      "Onboarding flows with progressive disclosure",
      "Camera or recording app interfaces",
      "Tutorial sequences with scroll-based progression"
    ],
    "secondary": [
      "Interactive demos and showcases",
      "Social media story viewers",
      "Product tours with scroll interaction",
      "Documentation with scroll-based reveals",
      "App store preview interactions"
    ],
    "real_world_examples": [
      "Instagram/Snapchat story interfaces",
      "TikTok-style vertical video feeds",
      "Notion-style continuous scrolling",
      "Apple product showcase pages",
      "Camera app with slide-up recording"
    ],
    "not_recommended_for": [
      "Horizontal scrolling (inverted pattern is vertical-specific)",
      "Long-form content (snapping may be disruptive)",
      "Accessibility-critical contexts (complex scroll interaction)",
      "Navigation-heavy apps (unconventional scroll pattern)"
    ]
  },
  "code_quality": {
    "typescript": {
      "coverage": "Full TypeScript with explicit types",
      "type_imports": "type keyword for type-only imports (FC, StyleProp, ViewStyle, SharedValue, FlatList)",
      "prop_types": "Explicit RecordButtonProps interface with all props typed",
      "type_safety": "Proper SharedValue<number> typing, as any for ref compatibility"
    },
    "component_structure": {
      "separation": "Clean separation between demo (index.tsx) and reusable component (record-button/index.tsx)",
      "utility_extraction": "Skia path creation extracted to create-skia-line.ts",
      "haptics_wrapper": "Haptics abstracted to utils/haptics.ts",
      "reusability": "RecordButton fully reusable with prop configuration"
    },
    "constants": {
      "extracted": [
        "ButtonWidth = 90",
        "ButtonHeight = 40",
        "ButtonRadius = 20",
        "StrokeWidth = 1",
        "ButtonColor = '#ed4e3c'"
      ],
      "documented": "Comment: 'you can play with these values'",
      "dimensions": "WindowWidth, WindowHeight from Dimensions.get('window')"
    },
    "comments": {
      "scroll_hook": "Comment explaining useScrollViewOffset",
      "snapping_code": "Honest comment about being unhappy with snapping code",
      "text_choice": "Comment explaining choice of Animated.Text over Skia",
      "path_function": "Detailed comment about recreating path function incrementally",
      "tone": "Conversational and educational"
    },
    "naming_conventions": {
      "components": "PascalCase",
      "props": "camelCase",
      "shared_values": "camelCase (scrollOffset, shouldEnableSnapping)",
      "animated_styles": "rStyle prefix convention",
      "clarity": "Descriptive names (internalRoundedRectOpacity, basePathProps)"
    },
    "eslint_pragmas": {
      "used": "eslint-disable-next-line @typescript-eslint/no-explicit-any",
      "locations": "Type casts for ref compatibility",
      "used_hooks": "eslint-disable-next-line react-hooks/exhaustive-deps",
      "reason": "Manual dependency management in callbacks with shared values"
    },
    "best_practices": [
      "useMemo for expensive computations (path creation)",
      "useCallback for stable function references",
      "Proper TypeScript typing throughout",
      "Clean separation of concerns",
      "Educational comments",
      "Extracted utility functions",
      "Worklet-optimized scroll callbacks"
    ]
  },
  "known_limitations": {
    "typescript_any_casts": {
      "issue": "useAnimatedRef and useScrollViewOffset require 'as any' casts",
      "locations": [
        "scrollRef as any",
        "scrollOffset hook"
      ],
      "reason": "Reanimated type definitions don't fully support FlatList",
      "impact": "Loss of type safety at ref boundaries"
    },
    "snapping_complexity": {
      "author_note": "I'm really unhappy with this code",
      "issue": "Custom snapping logic is complex and fragile",
      "reason": "Mimics specific behavior of original app",
      "potential": "Could be simplified or made more configurable"
    },
    "hardcoded_values": {
      "progress_input_range": "[WindowHeight * 0.08, WindowHeight * 0.2]",
      "activation_threshold": "0.98",
      "snapping_threshold": "0.9 and 0.97",
      "enhancement": "Could be props for better customization"
    },
    "inverted_list_limitations": {
      "complexity": "Inverted FlatList can be confusing",
      "accessibility": "May cause issues with screen readers",
      "platform_differences": "Behavior may vary between iOS/Android"
    },
    "no_gesture_handler": {
      "current": "Uses basic FlatList scroll events",
      "limitation": "Less control over gesture lifecycle",
      "potential": "Could use Gesture.Pan() for finer control"
    }
  },
  "potential_improvements": {
    "features": [
      "Configurable progress input ranges as props",
      "Multiple snap points with configurable thresholds",
      "Support for horizontal orientation",
      "Customizable activation threshold",
      "Alternative path shapes (square, triangle)",
      "Recording animation after activation (pulsing red dot)"
    ],
    "interaction": [
      "Long press for different action",
      "Swipe to dismiss/reset",
      "Gesture handler for better scroll control",
      "Haptic intensity based on progress",
      "Sound effects on activation"
    ],
    "customization": [
      "Configurable spring configs as props",
      "Custom path creation function prop",
      "Gradient color support",
      "Multiple color stops for path",
      "Animated icon instead of text"
    ],
    "accessibility": [
      "Screen reader announcements",
      "Reduce motion support",
      "Alternative non-scroll activation method",
      "Focus indicators",
      "High contrast mode support"
    ],
    "code_quality": [
      "Extract snapping logic to separate hook",
      "Better TypeScript types for refs",
      "Make magic numbers configurable",
      "Add comprehensive prop validation",
      "Improve comments on snapping logic"
    ],
    "performance": [
      "Memo wrapper for RecordButton",
      "Lazy loading for screens",
      "Virtualization for more screens",
      "Optimize re-renders with React.memo"
    ]
  },
  "key_insights": {
    "inverted_flatlist_pattern": "Inverted FlatList creates unique upward scroll reveal effect",
    "scroll_offset_hook": "useScrollViewOffset is powerful for scroll-driven animations",
    "skia_path_mirroring": "Matrix transformations enable DRY principle for symmetric paths",
    "path_end_prop": "Skia Path 'end' prop is perfect for draw-on animations (0 to 1)",
    "activation_edge_detection": "useAnimatedReaction excellent for one-time effects on state transitions",
    "scheduleOnRN_pattern": "scheduleOnRN bridges worklets to JS thread for non-workletized functions",
    "custom_snapping": "Sometimes platform APIs need custom logic to match design requirements",
    "border_curve_continuous": "borderCurve: 'continuous' creates Apple-style squircle effect",
    "asymmetric_thresholds": "Different thresholds for different behaviors (0.9, 0.97, 0.98) create nuanced UX",
    "reanimated_flatlist": "Animated.FlatList with worklet callbacks enables complex scroll interactions",
    "shared_value_in_callbacks": "Shared values in useCallback dependencies can be excluded with pragma"
  },
  "learning_opportunities": {
    "for_beginners": [
      "FlatList basics and inverted prop",
      "Scroll event handling",
      "useSharedValue and progress-driven animations",
      "Basic Skia Canvas and Path rendering",
      "Haptic feedback integration"
    ],
    "for_intermediate": [
      "useScrollViewOffset for scroll tracking",
      "useDerivedValue for computed animation values",
      "Skia path creation with moveTo, lineTo, rArcTo",
      "Matrix transformations for path mirroring",
      "useAnimatedReaction for edge detection",
      "Custom snap behavior implementation",
      "Interpolate with CLAMP extrapolation"
    ],
    "for_advanced": [
      "Complex scroll-driven animation systems",
      "Custom Skia path construction techniques",
      "Worklet-to-JS thread bridging with scheduleOnRN",
      "FlatList performance optimization with worklets",
      "Inverted list patterns for unique UX",
      "Coordinated multi-property animations",
      "Scroll threshold tuning for optimal feel",
      "Building reusable scroll-animated components"
    ]
  },
  "testing_considerations": {
    "visual_regression": [
      "Paths draw smoothly from 0 to 1 progress",
      "Left and right paths are perfectly mirrored",
      "Border radius on HomeScreen animates smoothly",
      "Text opacity fades in with progress",
      "Button scales up on activation",
      "RoundedRect appears at correct timing"
    ],
    "interaction_testing": [
      "Scroll triggers path drawing correctly",
      "Activation occurs at >98% progress",
      "Haptic feedback fires once on activation",
      "Button press scrolls to index 0",
      "Snapping behavior works as intended",
      "Scroll from top doesn't trigger unwanted snap"
    ],
    "edge_cases": [
      "Very fast scrolling",
      "Rapid scroll direction changes",
      "Button press during scroll",
      "Multiple rapid activations",
      "Scroll offset edge values (0, max)"
    ],
    "performance_testing": [
      "Smooth 60fps during scroll",
      "No jank on Skia path rendering",
      "Haptic doesn't block UI thread",
      "Memory stable across scroll cycles",
      "Fast scroll doesn't drop frames"
    ],
    "cross_platform": [
      "Inverted FlatList behavior (iOS vs Android)",
      "Haptic feedback availability",
      "Border curve rendering (iOS-specific)",
      "Scroll physics differences",
      "Skia rendering consistency"
    ]
  },
  "comparison_to_similar_patterns": {
    "vs_progress_bar": {
      "similarity": "Both use progress value to drive visual",
      "difference": "This uses custom Skia paths, progress bar typically simpler",
      "interaction": "This is scroll-driven, progress bars often time-driven"
    },
    "vs_svg_path_animation": {
      "similarity": "Path drawing animation technique",
      "difference": "This uses Skia (GPU), SVG is often CPU-rendered",
      "performance": "Skia generally more performant for complex paths"
    },
    "vs_scroll_reveal": {
      "similarity": "Content reveals on scroll",
      "difference": "This uses inverted list and custom paths",
      "complexity": "This is more advanced with snap and activation logic"
    }
  },
  "related_patterns": {
    "path_animation": "SVG/Skia path drawing animations",
    "scroll_parallax": "Scroll-driven visual effects",
    "story_ui": "Vertical full-screen scrolling interfaces",
    "progress_indicator": "Visual progress feedback",
    "reveal_animation": "Progressive disclosure patterns"
  },
  "real_world_inspiration": {
    "instagram_stories": "Inverted vertical scrolling pattern",
    "tiktok_feed": "Snap-to-screen vertical scroll",
    "camera_apps": "Slide-up-to-record interaction",
    "apple_design": "Continuous border curve, smooth animations",
    "material_design": "Haptic feedback on state changes"
  },
  "bundle_size_impact": {
    "code_size": "~149 lines (index) + ~168 lines (button) + ~47 lines (path) + ~6 lines (haptics) = ~370 lines",
    "dependencies": {
      "reanimated": "Likely already in project",
      "skia": "Large dependency (~10MB), likely already in project",
      "pressto": "Small (~1KB)",
      "expo-haptics": "Small Expo module"
    },
    "runtime_memory": "Minimal - few shared values, memoized paths",
    "estimated_size": "< 10KB (excluding deps)"
  },
  "accessibility_considerations": {
    "current_state": {
      "screen_readers": "No accessibility labels on button",
      "keyboard_navigation": "Not applicable (scroll-based)",
      "reduced_motion": "No support - animations always run",
      "inverted_list": "May confuse screen readers",
      "haptics": "Good for users relying on tactile feedback"
    },
    "recommendations": [
      "Add accessibilityLabel to RecordButton",
      "Add accessibilityHint explaining scroll-to-activate",
      "Set accessibilityRole to 'button'",
      "Respect prefers-reduced-motion (simplify or disable animations)",
      "Consider alternative activation method for accessibility",
      "Add screen reader announcements for activation state",
      "Test with VoiceOver/TalkBack for inverted list behavior"
    ],
    "implementation_suggestions": {
      "reduced_motion": "Skip scroll-driven reveal, show button immediately",
      "alternative_activation": "Add direct tap activation without scroll requirement",
      "announcements": "Use AccessibilityInfo.announceForAccessibility on activation"
    }
  },
  "tags": [
    "scroll-animation",
    "skia-paths",
    "inverted-flatlist",
    "path-drawing",
    "record-button",
    "haptic-feedback",
    "progress-animation",
    "snap-to-scroll",
    "reanimated",
    "react-native-skia",
    "matrix-transformation",
    "scroll-driven",
    "activation-state",
    "border-curve",
    "pressto"
  ],
  "content_hash": "0cc232619fa16d11e3a96254b47da6f1ee47e29f18131b7c743d12fd17ca6b2e",
  "hash_algorithm": "sha256",
  "hash_generated_at": "2025-10-12T09:19:28.416Z",
  "last_validated": "2025-10-12T09:19:28.416Z"
}
