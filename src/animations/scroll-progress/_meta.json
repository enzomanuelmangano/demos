{
  "animation_name": "Scroll Progress",
  "animation_slug": "scroll-progress",
  "description": "An intelligent scroll progress indicator with reading time estimation that displays a collapsible bottom bar showing scroll percentage, reading time, and a reset button. Features state-based UI transitions that adapt based on scroll position (initial, expanded, end) with smooth animations and automatic scroll-to-top functionality.",

  "main_features": [
    "Dynamic scroll progress tracking with percentage display",
    "Automatic reading time calculation based on content",
    "State-based UI transitions (initial, expanded, end states)",
    "Collapsible bottom progress bar with animated width transitions",
    "Scroll-to-top reset functionality with animated scrolling",
    "Intelligent scroll event handling with reset state management",
    "Progress bar with real-time percentage text using ReText",
    "Responsive layout calculation based on viewport dimensions",
    "Smooth spring and timing animations for all transitions",
    "ScrollView content measurement and layout tracking"
  ],

  "file_structure": {
    "entries": {
      "index.tsx": "Main ScrollProgress component with section rendering"
    },
    "components": {
      "section-content-list/index.tsx": "Core SectionContentList component with scroll handling and progress tracking",
      "section-content-list/bottom-progress/index.tsx": "BottomProgress container managing state transitions and width animations",
      "section-content-list/bottom-progress/progress-bar-area.tsx": "ProgressBarArea displaying percentage and progress bar when expanded",
      "section-content-list/bottom-progress/collapsed-area.tsx": "CollapsedArea showing reading time initially and up arrow at end"
    },
    "hooks": {},
    "utils": {
      "section-content-list/utils/clamp.ts": "Worklet function to clamp values within bounds",
      "section-content-list/utils/get-reading-time.ts": "Calculate estimated reading time from text content",
      "section-content-list/utils/index.ts": "Barrel export for utility functions"
    },
    "assets": {},
    "types": {
      "section-content-list/typings.ts": "BottomProgressState enum (INITIAL, EXPANDED, END)"
    },
    "constants": {
      "constants.ts": "Section data with titles and descriptions (chess openings content)"
    }
  },

  "core_technologies": {
    "animations": "react-native-reanimated",
    "text_rendering": "react-native-redash (ReText)",
    "layout": "react-native-safe-area-context"
  },

  "packages_and_versions": {
    "react-native-reanimated": {
      "version": "~4.1.1",
      "hooks": [
        "useSharedValue",
        "useAnimatedScrollHandler",
        "useDerivedValue",
        "useAnimatedStyle",
        "useAnimatedReaction",
        "interpolate"
      ],
      "components": ["Animated.ScrollView", "Animated.View"],
      "functions": ["withTiming", "withSpring", "Extrapolation"],
      "critical_feature": "useAnimatedScrollHandler for native thread scroll handling"
    },
    "react-native-redash": {
      "version": "^18.1.4",
      "components": ["ReText"],
      "usage": "Animated text component for real-time percentage display without re-renders",
      "benefit": "Updates text on UI thread without bridging to JS thread"
    },
    "react-native-safe-area-context": {
      "version": "~5.6.0",
      "hooks": ["useSafeAreaInsets"],
      "usage": "Safe area padding for top and bottom insets"
    },
    "@expo/vector-icons": {
      "version": "^15.0.2",
      "components": ["AntDesign"],
      "icons_used": ["arrow-up"],
      "usage": "Up arrow icon for scroll-to-top button"
    }
  },

  "animation_techniques": {
    "scroll_progress_tracking": {
      "pattern": "useAnimatedScrollHandler with derived progress value",
      "calculation": "progress = clamp(scrollY / scrollableHeight, 0, 1)",
      "scrollableHeight": "contentHeight - viewportHeight + paddingBottom",
      "clamping": "[0, 1] to ensure valid percentage",
      "updates": "On every scroll event (scrollEventThrottle: 16)",
      "effect": "Real-time progress tracking normalized to 0-1 range"
    },
    "state_machine": {
      "pattern": "useDerivedValue with conditional state logic",
      "states": {
        "INITIAL": "progress === 0 (at top)",
        "EXPANDED": "0 < progress < 1 (scrolling)",
        "END": "progress === 1 (at bottom)"
      },
      "implementation": "Enum-based state transitions in typings.ts",
      "effect": "Clean state-based UI logic for three distinct modes"
    },
    "width_transition": {
      "pattern": "Animated width with timing animation",
      "values": "70px (collapsed) to 200px (expanded)",
      "timing": {
        "duration": 500
      },
      "trigger": "isExpanded derived value change",
      "effect": "Bottom bar grows/shrinks based on scroll state"
    },
    "opacity_crossfade": {
      "pattern": "Multiple animated views with opacity transitions",
      "components": [
        "ProgressBarArea: opacity 1 when expanded, 0 otherwise",
        "CollapsedArea: opacity 1 when INITIAL or END, 0 when expanded",
        "MinContainer (inside CollapsedArea): opacity 1 when INITIAL",
        "UpArrowContainer (inside CollapsedArea): opacity 1 when END"
      ],
      "animation": "withTiming",
      "effect": "Smooth crossfade between different UI states"
    },
    "progress_bar_fill": {
      "pattern": "Width interpolation with percentage",
      "interpolation": "interpolate(progress, [0, 1], [0, 100], CLAMP)",
      "style": "width: `${percentage}%`",
      "extrapolation": "Extrapolation.CLAMP to prevent overflow",
      "effect": "Progress bar fills from left to right"
    },
    "percentage_text": {
      "pattern": "ReText with derived string value",
      "calculation": "`${Math.round(progress * 100)}%`",
      "component": "ReText from react-native-redash",
      "benefit": "Text updates on UI thread without re-renders",
      "effect": "Real-time percentage display during scroll"
    },
    "reset_scroll_handling": {
      "pattern": "isResetting flag with useAnimatedReaction",
      "lifecycle": {
        "onReset": "Set isResetting to true, scrollTo({y: 0, animated: true})",
        "during_reset": "Ignore scroll events (prevent progress updates)",
        "completion": "useAnimatedReaction detects currentScroll === 0, sets isResetting to false"
      },
      "purpose": "Prevent progress updates during programmatic scrolling",
      "effect": "Clean reset animation without flickering progress"
    }
  },

  "reanimated_patterns": {
    "shared_values": [
      {
        "name": "viewHeight",
        "initial": 1000,
        "purpose": "Store viewport height from layout measurement",
        "updates": "onLayout callback in main View"
      },
      {
        "name": "scrollHeight",
        "initial": 1000,
        "purpose": "Store content height from layout measurement",
        "updates": "onLayout callback in content View"
      },
      {
        "name": "progress",
        "initial": 0,
        "purpose": "Normalized scroll progress (0-1)",
        "updates": "useAnimatedScrollHandler onScroll"
      },
      {
        "name": "isResetting",
        "initial": false,
        "purpose": "Flag to ignore scroll events during reset",
        "updates": "onReset callback and useAnimatedReaction"
      },
      {
        "name": "currentScroll",
        "initial": 0,
        "purpose": "Track current scroll position for reset detection",
        "updates": "useAnimatedScrollHandler onScroll"
      }
    ],
    "derived_values": [
      {
        "name": "scrollableHeight",
        "calculation": "scrollHeight - viewHeight + paddingBottom",
        "dependencies": ["scrollHeight", "viewHeight", "paddingBottom"],
        "purpose": "Calculate total scrollable distance"
      },
      {
        "name": "state",
        "calculation": "Conditional based on progress value",
        "logic": "progress === 0 ? INITIAL : progress === 1 ? END : EXPANDED",
        "purpose": "Derive current UI state from progress"
      },
      {
        "name": "isExpanded",
        "calculation": "state === BottomProgressState.EXPANDED",
        "dependencies": ["state"],
        "purpose": "Boolean flag for expanded state"
      },
      {
        "name": "animatedPercentage",
        "calculation": "`${Math.round(progress * 100)}%`",
        "purpose": "Formatted percentage string for ReText"
      }
    ],
    "useAnimatedScrollHandler": {
      "pattern": "Standard onScroll handler pattern",
      "runs_on": "UI thread (native)",
      "event_properties": ["contentOffset.y"],
      "updates": ["currentScroll", "progress (conditionally)"],
      "conditional_logic": "Skip progress update if isResetting.value is true",
      "benefit": "60fps scroll handling without bridge crossing"
    },
    "useAnimatedReaction": {
      "watches": "isResetting && currentScroll === 0",
      "callback": "Set isResetting to false when condition is true",
      "purpose": "Detect when reset scroll animation completes",
      "pattern": "Derived condition + side effect",
      "benefit": "Clean state management for async scroll operations"
    },
    "animated_styles": {
      "rAnimatedStyle (BottomProgress)": {
        "properties": ["width"],
        "animation": "withTiming",
        "interpolation": "Conditional based on isExpanded"
      },
      "rAnimatedStyle (ProgressBarArea)": {
        "properties": ["opacity"],
        "animation": "withTiming",
        "trigger": "isVisible derived value"
      },
      "rProgressBarAnimatedStyle": {
        "properties": ["width"],
        "interpolation": "interpolate(progress, [0, 1], [0, 100])",
        "unit": "percentage string"
      },
      "rCollapsedAreaStyle": {
        "properties": ["opacity"],
        "logic": "Visible when INITIAL or END state"
      },
      "rMinContainerStyle": {
        "properties": ["opacity"],
        "logic": "Visible when INITIAL state"
      },
      "rUpArrowContainerStyle": {
        "properties": ["opacity"],
        "logic": "Visible when END state"
      }
    },
    "worklet_functions": {
      "clamp": {
        "signature": "(value, lowerBound, upperBound) => number",
        "worklet": true,
        "logic": "Math.min(Math.max(value, lowerBound), upperBound)",
        "purpose": "Constrain progress to valid range [0, 1]"
      }
    }
  },

  "performance_optimizations": {
    "memo_components": {
      "SectionContentList": "Prevents re-render when parent state changes",
      "BottomProgress": "Prevents re-render when non-essential props change",
      "ProgressBarArea": "Prevents re-render during state transitions",
      "CollapsedArea": "Prevents re-render during state transitions",
      "benefit": "Only re-renders when SharedValues trigger style changes"
    },
    "useMemo_optimizations": [
      {
        "name": "paddingBottom",
        "location": "SectionContentList",
        "calculation": "StyleSheet.flatten to extract paddingBottom from contentContainerStyle",
        "dependencies": ["contentContainerStyle"],
        "purpose": "Prevent recalculation on every render"
      },
      {
        "name": "readingTime",
        "location": "SectionContentList",
        "calculation": "Sum of getReadingTime for all sections",
        "dependencies": ["sections"],
        "purpose": "Calculate reading time once on mount"
      }
    ],
    "useCallback_optimizations": [
      {
        "name": "onLayout",
        "location": "SectionContentList",
        "dependencies": ["scrollHeight"],
        "purpose": "Stable reference for layout callback"
      },
      {
        "name": "onReset",
        "location": "SectionContentList",
        "dependencies": ["isResetting"],
        "purpose": "Stable reference for reset button callback"
      },
      {
        "name": "renderSection",
        "location": "ScrollProgress",
        "dependencies": "[]",
        "purpose": "Stable render prop for section rendering"
      },
      {
        "name": "onPressArrow",
        "location": "CollapsedArea",
        "dependencies": ["onReset", "state.value"],
        "purpose": "Stable touch handler with state checking"
      }
    ],
    "scroll_event_throttle": {
      "value": 16,
      "fps_equivalent": "~60 fps",
      "benefit": "Balance between smooth updates and performance"
    },
    "layout_measurement": {
      "pattern": "onLayout callbacks for dynamic height calculation",
      "measurements": ["viewHeight", "scrollHeight"],
      "benefit": "Responsive to different content sizes without hardcoding"
    },
    "conditional_scroll_handling": {
      "pattern": "Check isResetting flag before updating progress",
      "benefit": "Avoid unnecessary SharedValue updates during reset animation",
      "prevents": "Progress flickering during scrollTo"
    },
    "retext_optimization": {
      "component": "ReText for percentage display",
      "benefit": "Updates text on UI thread without triggering React re-renders",
      "alternative": "Regular Text would require setState and re-render on every scroll"
    }
  },

  "state_management": {
    "animation_flow": {
      "scroll_interaction": [
        "1. User scrolls content",
        "2. useAnimatedScrollHandler captures contentOffset.y",
        "3. currentScroll SharedValue updated",
        "4. Check isResetting flag (skip if true)",
        "5. Calculate progress = clamp(y / scrollableHeight, 0, 1)",
        "6. progress SharedValue updated",
        "7. state derived value recalculates (INITIAL/EXPANDED/END)",
        "8. isExpanded derived value recalculates",
        "9. Multiple useAnimatedStyle hooks trigger",
        "10. UI updates: width animation, opacity transitions, progress bar fill",
        "11. ReText updates percentage display"
      ],
      "reset_interaction": [
        "1. User taps up arrow when progress === 1",
        "2. onPressArrow checks state.value === END",
        "3. onReset callback called",
        "4. isResetting set to true",
        "5. scrollRef.current?.scrollTo({y: 0, animated: true})",
        "6. Native scroll animation begins",
        "7. Scroll events fire but are ignored (isResetting === true)",
        "8. useAnimatedReaction monitors: isResetting && currentScroll === 0",
        "9. When scroll reaches top, condition becomes true",
        "10. isResetting set to false",
        "11. Normal scroll tracking resumes"
      ]
    },
    "state_transitions": {
      "INITIAL → EXPANDED": "User starts scrolling from top (progress: 0 → >0)",
      "EXPANDED → END": "User scrolls to bottom (progress: <1 → 1)",
      "END → INITIAL": "User taps up arrow, reset animation runs",
      "EXPANDED → INITIAL": "User manually scrolls back to top",
      "visual_changes": {
        "INITIAL": "Width: 70px, Shows reading time",
        "EXPANDED": "Width: 200px, Shows progress bar and percentage",
        "END": "Width: 70px, Shows up arrow"
      }
    }
  },

  "visual_design": {
    "color_scheme": {
      "background": "#111 (dark black)",
      "bottom_bar_bg": "#222123 (dark gray)",
      "progress_area_bg": "#2E2D2E (medium gray)",
      "collapsed_area_bg": "#2E2D2E (medium gray)",
      "text_primary": "#EEE (light gray - section titles)",
      "text_secondary": "#999 (medium gray - section descriptions)",
      "text_tertiary": "#9E9E9E (progress percentage, reading time)",
      "progress_bar_track": "#1A1A1A (dark track)",
      "progress_bar_fill": "#9E9E9E (gray fill)",
      "progress_bar_container": "#fff (white container)",
      "border": "rgba(255,255,255,0.1) (subtle white border)",
      "aesthetic": "Dark mode design with subtle grays"
    },
    "typography": {
      "section_title": {
        "fontSize": 20,
        "fontWeight": "bold",
        "color": "#EEE"
      },
      "section_description": {
        "fontSize": 14,
        "color": "#999"
      },
      "progress_percentage": {
        "fontSize": 15,
        "color": "#9E9E9E",
        "width": 50,
        "textAlign": "center"
      },
      "reading_time": {
        "color": "#9E9E9E",
        "adjustsFontSizeToFit": true,
        "numberOfLines": 1,
        "marginHorizontal": 5
      }
    },
    "bottom_progress_bar": {
      "dimensions": {
        "height": 70,
        "width_collapsed": 70,
        "width_expanded": 200,
        "borderRadius": 40,
        "margin": 5
      },
      "positioning": {
        "position": "absolute",
        "bottom": 50,
        "alignSelf": "center",
        "zIndex": 100
      },
      "border": {
        "borderWidth": 0.5,
        "borderColor": "rgba(255,255,255,0.1)"
      },
      "transition": {
        "property": "width",
        "duration": 500,
        "animation": "withTiming"
      }
    },
    "progress_bar": {
      "container": {
        "height": 5,
        "width": "70%",
        "backgroundColor": "#fff",
        "borderRadius": 40,
        "overflow": "hidden"
      },
      "track": {
        "position": "absolute",
        "fill": true,
        "backgroundColor": "#1A1A1A"
      },
      "fill": {
        "position": "absolute",
        "fill": true,
        "backgroundColor": "#9E9E9E",
        "animates": "width (0% to 100%)"
      }
    },
    "layout": {
      "main_container": "flex: 1, dark background, safe area insets",
      "scroll_content": "paddingHorizontal: 20, paddingTop: 20, paddingBottom: 100",
      "section_spacing": "marginBottom: 20",
      "icon_size": "24 (up arrow)"
    },
    "animations": {
      "width_transition": "500ms timing",
      "opacity_transitions": "Default timing duration",
      "scroll_reset": "Animated scrollTo with native spring"
    }
  },

  "mathematical_algorithms": {
    "progress_calculation": {
      "formula": "progress = clamp(scrollY / scrollableHeight, 0, 1)",
      "variables": {
        "scrollY": "Current scroll offset (contentOffset.y)",
        "scrollableHeight": "contentHeight - viewportHeight + paddingBottom",
        "contentHeight": "Total height of scrollable content",
        "viewportHeight": "Visible viewport height",
        "paddingBottom": "Bottom padding from contentContainerStyle"
      },
      "clamping": "Ensures progress stays in [0, 1] range",
      "example": "If scrollY = 500, scrollableHeight = 1000 → progress = 0.5 (50%)"
    },
    "scrollable_height": {
      "formula": "scrollHeight - viewHeight + paddingBottom",
      "purpose": "Calculate total scrollable distance",
      "padding_adjustment": "Accounts for contentContainerStyle paddingBottom",
      "example": "scrollHeight = 2000, viewHeight = 800, paddingBottom = 100 → scrollableHeight = 1300"
    },
    "percentage_display": {
      "formula": "Math.round(progress * 100)",
      "output": "Integer percentage (0-100)",
      "formatting": "Appended with '%' symbol",
      "example": "progress = 0.567 → 57%"
    },
    "progress_bar_width": {
      "formula": "interpolate(progress, [0, 1], [0, 100], CLAMP)",
      "output": "Percentage string for width style",
      "example": "progress = 0.75 → width: '75%'"
    },
    "reading_time_calculation": {
      "function": "getReadingTime(text)",
      "algorithm": "word count / 200 words per minute",
      "word_count": "text.split(/\\s/g).length",
      "rounding": "Math.ceil for conservative estimate",
      "aggregation": "Sum reading time across all sections",
      "example": "400 words → 2 minutes"
    },
    "clamp_function": {
      "formula": "Math.min(Math.max(value, lowerBound), upperBound)",
      "steps": [
        "1. Math.max(value, lowerBound) - Ensure not below minimum",
        "2. Math.min(..., upperBound) - Ensure not above maximum"
      ],
      "example": "clamp(1.5, 0, 1) → 1"
    }
  },

  "layout_and_positioning": {
    "absolute_positioning": {
      "bottom_progress": {
        "position": "absolute",
        "bottom": 50,
        "alignSelf": "center",
        "zIndex": 100,
        "purpose": "Float above scroll content"
      }
    },
    "layering_strategy": {
      "z_index": 100,
      "ensures": "Progress bar always visible above scrolling content",
      "alternative": "Could use separate View but absolute simpler"
    },
    "safe_area_handling": {
      "insets": "useSafeAreaInsets()",
      "paddingTop": "insets.top",
      "paddingBottom": "insets.bottom",
      "benefit": "Respects device notches and home indicators"
    },
    "responsive_measurements": {
      "viewport_height": "Measured via onLayout on main View",
      "content_height": "Measured via onLayout on content View",
      "dynamic": "Adapts to different screen sizes and content lengths",
      "no_hardcoding": "All dimensions calculated at runtime"
    },
    "overflow_handling": {
      "progress_bar_container": "overflow: 'hidden'",
      "purpose": "Clip progress bar fill animation within rounded container"
    }
  },

  "use_cases": {
    "primary": [
      "Article readers with progress tracking",
      "Long-form content consumption apps",
      "Documentation viewers",
      "Blog post readers",
      "E-book reading interfaces",
      "Tutorial pages with progress indication"
    ],
    "secondary": [
      "Terms and conditions scrolling",
      "Privacy policy viewers",
      "Legal document readers",
      "Educational content apps",
      "News article readers",
      "Recipe instructions with progress"
    ],
    "real_world_inspiration": [
      "Medium article progress bars",
      "Substack reading indicators",
      "Kindle reading progress",
      "Documentation sites (Notion, Confluence)",
      "Mobile news apps"
    ]
  },

  "code_quality": {
    "strengths": [
      "Full TypeScript with explicit type definitions",
      "Clean component separation and single responsibility",
      "Proper use of memo for all animated components",
      "Comprehensive optimization with useMemo and useCallback",
      "Well-structured file organization with clear naming",
      "State machine pattern with enum for clarity",
      "Smart reset handling with isResetting flag",
      "Proper worklet annotations on utility functions",
      "Good use of derived values for computed state",
      "ReText for performance-optimized text updates",
      "Safe area awareness for device compatibility",
      "Responsive design with dynamic measurements"
    ],
    "areas_for_improvement": [
      "No accessibility labels or screen reader support",
      "Touch target for up arrow could be larger (currently icon-only)",
      "No haptic feedback on reset action",
      "Constants file contains presentation data (could be props)",
      "Magic numbers (50, 70, 200, 500) could be extracted to constants",
      "No error handling if scrollRef is null",
      "onPressArrow uses onTouchEnd instead of proper gesture or Pressable",
      "Type 'any' used for onLayout event parameter",
      "No loading state for content measurement",
      "Reading time calculation could be more sophisticated (images, code blocks)"
    ]
  },

  "typescript_quality": {
    "type_definitions": [
      "Section type",
      "SectionContentListProps with ScrollViewProps extension",
      "BottomProgressProps",
      "ProgressBarAreaProps",
      "CollapsedAreaProps",
      "BottomProgressState enum"
    ],
    "type_imports": "Uses 'type' keyword for type-only imports",
    "prop_spreading": "Proper typing with ...scrollViewProps spread",
    "strict_typing": "SharedValue<boolean> and SharedValue<number> explicit",
    "areas_to_improve": [
      "onLayout event typed as 'any' (could use LayoutChangeEvent)",
      "Missing prop types for style props in some components"
    ]
  },

  "known_limitations": {
    "touch_target_size": {
      "issue": "Up arrow icon (24x24) may be too small for comfortable tapping",
      "location": "CollapsedArea line 76",
      "impact": "Potential usability issue on mobile",
      "improvement": "Add padding or larger hit area with hitSlop"
    },
    "gesture_handling": {
      "issue": "Uses onTouchEnd instead of Pressable or gesture handler",
      "location": "CollapsedArea line 76",
      "limitation": "No press feedback, no gesture cancellation",
      "improvement": "Use Pressable for better accessibility and feedback"
    },
    "fixed_dimensions": {
      "values": ["70px collapsed width", "200px expanded width", "bottom: 50"],
      "limitation": "May not scale well on all screen sizes",
      "improvement": "Calculate based on screen dimensions or typography"
    },
    "reading_time_algorithm": {
      "issue": "Simple word count / 200 WPM",
      "limitations": [
        "Doesn't account for images or media",
        "Doesn't consider code blocks or formatted content",
        "Same rate for all languages and reading levels"
      ],
      "improvement": "More sophisticated algorithm with content type detection"
    },
    "content_assumptions": {
      "issue": "Assumes text-based sections only",
      "limitation": "renderSection is user-provided but reading time assumes text",
      "improvement": "Allow reading time to be passed as prop or calculated differently"
    },
    "scroll_ref_null_safety": {
      "issue": "scrollRef.current?.scrollTo called without null check on result",
      "location": "SectionContentList onReset",
      "risk": "Low risk but could add defensive check"
    },
    "animation_duration_hardcoded": {
      "value": 500,
      "location": "BottomProgress width animation",
      "limitation": "Not configurable via props",
      "improvement": "Extract to constant or prop"
    },
    "no_scroll_to_position": {
      "feature": "Only supports scroll to top",
      "limitation": "Can't jump to arbitrary positions",
      "potential": "Could extend to support scroll to percentage"
    }
  },

  "potential_improvements": {
    "features": [
      "Chapter/section markers on progress bar",
      "Tap progress bar to jump to position",
      "Estimated time remaining display",
      "Scroll velocity indicator",
      "Auto-hide progress bar when not scrolling",
      "Share/bookmark functionality at current position",
      "Reading speed customization",
      "Dark/light theme support",
      "Configurable position (top, bottom, side)",
      "Multiple color schemes"
    ],
    "accessibility": [
      "Add accessibilityLabel to progress bar",
      "Add accessibilityHint to up arrow button",
      "Add accessibilityValue for current progress",
      "Screen reader announcements at progress milestones",
      "Larger touch target for up arrow (min 44x44 points)",
      "Support for reduced motion preference",
      "High contrast mode support",
      "Keyboard navigation support"
    ],
    "customization": [
      "Configurable collapsed/expanded widths as props",
      "Custom color themes via props",
      "Configurable animation durations",
      "Custom reading time algorithm",
      "Positioning options (top, bottom, left, right)",
      "Custom reset icon or text",
      "Configurable progress bar styles",
      "Optional percentage vs fraction display"
    ],
    "performance": [
      "Memoize style objects in ProgressBarArea",
      "Consider requestAnimationFrame for layout measurements",
      "Add scroll debouncing option for heavy content",
      "Optimize ReText component re-renders",
      "Lazy load sections beyond viewport"
    ],
    "ux_enhancements": [
      "Haptic feedback on reset and at 100% progress",
      "Subtle animation when reaching end (celebrate completion)",
      "Reading streak/statistics tracking",
      "Scroll position persistence (remember position)",
      "Quick jump to previous position",
      "Reading mode with distraction-free view",
      "Adjustable text size from progress bar"
    ]
  },

  "key_insights": {
    "state_machine_pattern": "Using enum-based state (INITIAL, EXPANDED, END) provides clear, maintainable state logic",
    "reset_flag_critical": "isResetting flag prevents progress flickering during programmatic scrolling",
    "derived_state_power": "useDerivedValue for state calculation keeps logic on UI thread without callbacks",
    "retext_optimization": "ReText for percentage display avoids re-renders while updating on every scroll frame",
    "layout_measurement": "Dynamic height measurement makes component responsive without hardcoded dimensions",
    "useAnimatedReaction_for_detection": "Perfect for detecting async operation completion (scroll animation)",
    "multiple_opacity_layers": "Overlapping views with opacity transitions create smooth state changes",
    "clamping_essential": "Clamping progress to [0, 1] prevents edge cases from breaking UI",
    "memo_cascade": "Memoizing entire component tree prevents unnecessary re-renders during scroll",
    "width_animation_feel": "500ms timing for width gives substantial, intentional feel to expansion"
  },

  "learning_opportunities": {
    "for_beginners": [
      "Basic scroll event handling",
      "SharedValue fundamentals",
      "Simple derived values",
      "Layout measurement with onLayout",
      "Component composition",
      "Conditional rendering with opacity"
    ],
    "for_intermediate": [
      "useAnimatedScrollHandler patterns",
      "State machine implementation with enums",
      "Coordinated animations (width + opacity)",
      "Refs for imperative scrolling",
      "useDerivedValue for computed state",
      "ReText for animated text",
      "Safe area handling",
      "StyleSheet.flatten for style extraction"
    ],
    "for_advanced": [
      "useAnimatedReaction for async operation detection",
      "Reset flag pattern for programmatic scroll",
      "Scroll height calculation with dynamic padding",
      "Multi-layer opacity transition choreography",
      "Performance optimization with memo cascade",
      "Worklet-based utility functions",
      "Complex state derivation logic",
      "Reading time estimation algorithms"
    ]
  },

  "accessibility_considerations": {
    "current_state": "Minimal accessibility support",
    "missing_features": [
      "No accessibility labels on progress bar",
      "No accessibility hints on up arrow button",
      "No screen reader announcements",
      "Touch target too small (24x24 icon)",
      "No keyboard navigation support",
      "No reduced motion support"
    ],
    "recommendations": [
      "Add accessibilityRole='progressbar' to bottom bar",
      "Add accessibilityValue with percentage",
      "Add accessibilityLabel='Scroll to top' to up arrow",
      "Increase touch target to minimum 44x44 points",
      "Add announceForAccessibility on milestone progress",
      "Respect AccessibilityInfo.isReduceMotionEnabled",
      "Support keyboard shortcuts (Home key to reset)",
      "Add accessibilityHint='Double tap to return to top'",
      "Ensure color contrast meets WCAG AA standards"
    ]
  },

  "testing_considerations": {
    "visual_tests": [
      "Verify progress bar appears at bottom initially showing reading time",
      "Confirm expansion animation triggers when scrolling starts",
      "Check progress bar fills correctly from 0% to 100%",
      "Verify percentage text updates in real-time",
      "Confirm up arrow appears when reaching bottom",
      "Check collapse animation when at top or bottom",
      "Verify safe area insets on devices with notches"
    ],
    "interaction_tests": [
      "Scroll to bottom and verify progress reaches 100%",
      "Tap up arrow and verify smooth scroll to top",
      "Verify progress updates during scroll",
      "Test rapid scrolling doesn't break state",
      "Confirm no flicker during reset animation",
      "Test scroll position tracking accuracy",
      "Verify touch target responsiveness on up arrow"
    ],
    "edge_cases": [
      "Very short content (doesn't scroll)",
      "Very long content (thousands of sections)",
      "Dynamic content height changes",
      "Scroll during reset animation",
      "Multiple rapid reset taps",
      "Zero reading time content",
      "Screen rotation during scroll"
    ],
    "performance_tests": [
      "Monitor FPS during scrolling (target 60fps)",
      "Check memory usage with long content",
      "Verify no memory leaks on unmount",
      "Test scroll performance on low-end devices",
      "Measure animation smoothness",
      "Profile re-render count during scroll"
    ],
    "calculation_tests": [
      "Verify progress calculation accuracy at different scroll positions",
      "Test reading time calculation with various content lengths",
      "Confirm scrollableHeight calculation with different padding values",
      "Test clamp function boundary conditions",
      "Verify percentage rounding at edge values"
    ]
  },

  "related_patterns": {
    "similar_components": [
      "Medium reading progress indicator",
      "GitHub PR progress bar",
      "Video player progress",
      "Document viewer progress",
      "Instagram Stories progress bars"
    ],
    "complementary_animations": [
      "Floating action button (FAB) scroll behavior",
      "Collapsing toolbar on scroll",
      "Sticky headers with progress",
      "Parallax scroll effects",
      "Pull-to-refresh"
    ],
    "state_machine_examples": [
      "Bottom sheet (collapsed/expanded/closed)",
      "Media player (playing/paused/stopped/loading)",
      "Form wizard (step navigation)",
      "Onboarding flow states"
    ]
  },

  "performance_metrics": {
    "target_fps": 60,
    "runs_on": "UI thread for scroll handling",
    "expected_performance": "Smooth on all modern devices",
    "critical_optimizations": [
      "useAnimatedScrollHandler for native scroll",
      "ReText for text updates without re-renders",
      "memo components to prevent cascading updates",
      "useMemo for expensive calculations",
      "Derived values for state computation"
    ],
    "bottlenecks_to_avoid": [
      "Regular Text component for percentage (would re-render)",
      "setState in scroll handler (bridge crossing)",
      "Inline style objects (allocation on every frame)",
      "Unnecessary component re-renders"
    ]
  },

  "comparison_to_alternatives": {
    "vs_native_scrollbar": {
      "pros": [
        "Custom styling and branding",
        "Additional information (reading time, percentage)",
        "Interactive features (reset button)",
        "Better visibility (larger, always visible)",
        "Reading time estimation"
      ],
      "cons": [
        "Takes up screen space",
        "More implementation complexity",
        "Needs maintenance"
      ]
    },
    "vs_simple_percentage_text": {
      "this_approach": "Stateful UI with animations and reading time",
      "simple_approach": "Just show percentage text",
      "benefit": "Better UX with state awareness and interactions",
      "cost": "More code and complexity"
    },
    "vs_linear_progress_bar": {
      "this_approach": "Collapsible circular pill with state transitions",
      "linear_approach": "Fixed progress bar at top/bottom",
      "benefit": "Cleaner UI that adapts to reading state",
      "drawback": "More complex state management"
    }
  },

  "bundle_size_impact": {
    "code_size": "~450 lines total",
    "dependencies": "All dependencies common in React Native projects",
    "additional_package": "react-native-redash for ReText",
    "runtime_memory": "Minimal - few SharedValues, small component tree",
    "estimated_impact": "< 30KB minified"
  },

  "tags": [
    "scroll-progress",
    "reading-progress",
    "progress-indicator",
    "reading-time",
    "animated-progress-bar",
    "scroll-to-top",
    "reanimated",
    "state-machine",
    "collapsible-ui",
    "scroll-tracking",
    "retext",
    "derived-values",
    "content-reading",
    "article-reader",
    "useAnimatedScrollHandler",
    "opacity-transitions",
    "width-animation"
  ]
}
