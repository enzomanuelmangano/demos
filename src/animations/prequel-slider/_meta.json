{
  "animation_name": "Prequel Slider",
  "animation_slug": "prequel-slider",
  "description": "A sophisticated photo editing-style interface featuring a custom draggable slider with visual line indicators, dynamic color interpolation, circular progress display, and real-time GLSL shader effects. Inspired by photo editing apps like Prequel, this animation combines a horizontal draggable slider with snap points, GPU-accelerated butterfly wave shader transitions, and synchronized UI feedback including a donut circular progress indicator with color animation.",

  "main_features": [
    "Custom draggable slider with line-based visual indicators (50 lines)",
    "Snap-to-interval gesture handling with spring physics",
    "Real-time GLSL shader effects via React Native Skia (ButterflyWaveScrawler)",
    "Dynamic color interpolation from blue to orange based on progress",
    "Donut circular progress indicator synchronized with slider",
    "Boundary gradient fading for slider edges",
    "Responsive line heights (big/small lines every 10th line)",
    "Path-based Skia rendering for smooth line animations",
    "Clamped gesture boundaries with velocity-aware snapping",
    "GPU-accelerated image shader transitions with color separation",
    "Real-time uniform updates for shader progress",
    "Worklet-based progress callbacks for UI thread performance"
  ],

  "file_structure": {
    "entries": {
      "index.tsx": "Export wrapper with SafeAreaProvider and GestureHandlerRootView setup",
      "src/index.tsx": "Main App component orchestrating ImageEditor, DraggableSlider, and DonutCircularProgress"
    },
    "components": {
      "components/image-editor/index.tsx": "ImageEditor component rendering dual ImageShaders with GLSL transition effects",
      "components/draggable-slider/index.tsx": "DraggableSlider component with pan gesture, line path rendering, and snap points",
      "components/draggable-slider/boundary-gradient/index.tsx": "BoundaryGradient component for fade-out edges using LinearGradient",
      "components/donut-circular-progress/index.tsx": "DonutCircularProgress component rendering circular progress arc with dynamic color"
    },
    "utils": {
      "components/image-editor/utils/shader-lib.ts": "GLSL template literal utilities (glsl, frag) for shader compilation",
      "components/image-editor/utils/transition.ts": "Transition wrapper injecting uniform boilerplate into custom GLSL code",
      "components/image-editor/utils/index.ts": "Utility exports barrel file",
      "components/draggable-slider/utils/get-lines-path.ts": "Generates Skia Path for slider lines with viewport culling optimization",
      "components/draggable-slider/utils/snap-point.ts": "Snap point calculation using velocity and position (from react-native-redash)"
    },
    "transitions": {
      "gl-transition/index.ts": "ButterflyWaveScrawlerGL shader with butterfly polar function and color separation"
    },
    "constants": {
      "components/draggable-slider/constants.ts": "ScreenWidth constant from Dimensions API"
    }
  },

  "core_technologies": {
    "rendering": "@shopify/react-native-skia",
    "animations": "react-native-reanimated",
    "gestures": "react-native-gesture-handler",
    "shaders": "GLSL (OpenGL Shading Language)"
  },

  "packages_and_versions": {
    "@shopify/react-native-skia": {
      "version": "2.2.12",
      "components": [
        "Canvas",
        "Path",
        "Circle",
        "Group",
        "Fill",
        "Shader",
        "ImageShader",
        "LinearGradient",
        "Rect"
      ],
      "functions": [
        "Skia.Path.Make",
        "Skia.RuntimeEffect.Make",
        "useImage",
        "rect",
        "rrect"
      ],
      "hooks": [
        "useImage",
        "useFont"
      ],
      "usage": "GPU-accelerated rendering for custom slider lines, shader effects, and circular progress"
    },
    "react-native-reanimated": {
      "version": "~4.1.1",
      "hooks": [
        "useSharedValue",
        "useDerivedValue",
        "useAnimatedStyle",
        "useAnimatedReaction",
        "interpolateColor"
      ],
      "functions": [
        "withSpring",
        "cancelAnimation",
        "clamp",
        "interpolate"
      ],
      "components": [
        "Animated.View"
      ],
      "critical_feature": "Worklet-based gesture handling and UI thread calculations"
    },
    "react-native-gesture-handler": {
      "version": "~2.28.0",
      "components": [
        "GestureHandlerRootView",
        "GestureDetector"
      ],
      "functions": [
        "Gesture.Pan"
      ],
      "usage": "Pan gesture handling for draggable slider with velocity tracking"
    },
    "react-native-safe-area-context": {
      "version": "~5.6.0",
      "components": [
        "SafeAreaProvider"
      ],
      "hooks": [
        "useSafeAreaInsets"
      ],
      "usage": "Safe area insets for proper positioning on notched devices"
    },
    "react-native": {
      "version": "0.81.4",
      "hooks": [
        "useMemo",
        "useWindowDimensions"
      ],
      "modules": [
        "Dimensions",
        "StyleSheet",
        "View"
      ],
      "usage": "Core React Native primitives and layout"
    }
  },

  "animation_techniques": {
    "draggable_slider_lines": {
      "pattern": "Skia Path-based line rendering with dynamic positioning",
      "line_generation": {
        "total_lines": 50,
        "space_per_line": 10,
        "max_line_height": 12,
        "min_line_height": 5,
        "big_line_interval": "Every 10th line (0, 10, 20, 30, 40, 50)",
        "line_width": 2,
        "shape": "Rounded rectangles with 10px border radius"
      },
      "viewport_culling": {
        "pattern": "Skip rendering lines outside visible screen bounds",
        "calculation": "baseScrollView < offsetX - ScreenWidth/2 || baseScrollView > offsetX + ScreenWidth/2",
        "benefit": "Performance optimization - only renders ~10-15 visible lines instead of 50",
        "update": "Recalculates on every scroll offset change"
      },
      "path_separation": {
        "reason": "Big and small lines rendered in separate paths",
        "benefit": "Different opacity/color per line type (big: opacity 1, small: opacity 0.5)",
        "alternative": "Could be optimized but trade-off for visual control"
      },
      "scroll_offset_mapping": {
        "shared_value": "scrollOffset",
        "initial": "ScreenWidth / 2 (centered)",
        "range": "[ScreenWidth/2, -ProgressWidth + ScreenWidth/2]",
        "clamping": "Prevents scrolling beyond bounds",
        "position_calculation": "scrollOffsetX = offsetX + scrollOffset.value"
      }
    },
    "snap_points": {
      "algorithm": "react-native-redash snapPoint function",
      "formula": "point = value + 0.2 * velocity",
      "selection": "Finds closest snap point from calculated point",
      "velocity_multiplier": 0.2,
      "snap_interval": {
        "default": 1,
        "customizable": "snapEach prop (can set to 5, 10, etc.)",
        "calculation": "new Array(linesAmount / snapEach + 1)"
      },
      "spacings_array": "Pre-calculated snap positions for performance",
      "animation": "withSpring with mass: 0.45 for natural feel"
    },
    "progress_calculation": {
      "pattern": "useAnimatedReaction for scroll-to-progress mapping",
      "interpolation": {
        "input": "scrollOffset.value",
        "input_range": "[ScreenWidth/2, -ProgressWidth + ScreenWidth/2]",
        "output_range": "[0, 1]",
        "formula": "interpolate(offset, inputRange, [0, 1])"
      },
      "callback": "onProgressChange worklet function",
      "purpose": "Converts pixel scroll to 0-1 progress for shader and UI"
    },
    "color_interpolation": {
      "function": "interpolateColor from Reanimated",
      "input": "progressPercentage.value",
      "input_range": "[0, 1]",
      "color_range": "['#6d9bf1', 'orange']",
      "usage": [
        "DonutCircularProgress color",
        "DraggableSlider indicator color"
      ],
      "derived_value": "useDerivedValue for automatic updates",
      "performance": "Runs on UI thread"
    },
    "gesture_handling": {
      "gesture_type": "Gesture.Pan()",
      "onBegin": {
        "actions": [
          "Store scrollContext.value = scrollOffset.value",
          "cancelAnimation(scrollOffset)"
        ],
        "purpose": "Capture starting position and stop any ongoing animations"
      },
      "onUpdate": {
        "calculation": "scrollContext.value + event.translationX",
        "clamping": "clamp(value, -ProgressWidth + ScreenWidth/2, ScreenWidth/2)",
        "update": "scrollOffset.value = clampedValue"
      },
      "onEnd": {
        "animation": "withSpring to nearest snap point",
        "spring_config": { "mass": 0.45 },
        "velocity": "event.velocityX used for snap calculation",
        "alternative": "withDecay (commented out) for continuous scroll"
      }
    },
    "boundary_gradient": {
      "component": "BoundaryGradient with LinearGradient",
      "pattern": "Fade to background color at edges",
      "colors": ["mainColor", "transparent", "transparent", "transparent", "mainColor"],
      "positions": "5 stops with transparency in middle 60%",
      "direction": "Horizontal (start: {x:0, y:0}, end: {x:width, y:0})",
      "purpose": "Creates fade-out effect preventing hard cutoff at slider edges",
      "rendering": "Overlaid on top of line paths in same Canvas"
    },
    "indicator_line": {
      "implementation": "Animated.View with Animated styles",
      "positioning": {
        "horizontal": "left: ScreenWidth / 2 (always centered)",
        "vertical": "top: scrollableAreaHeight / 2 - indicatorLineHeight / 2"
      },
      "dimensions": {
        "width": "lineWidth * 1.4",
        "height": "maxLineHeight * 1.5",
        "border_radius": 10
      },
      "color": "useAnimatedStyle with interpolated color",
      "pointer_events": "none (non-interactive overlay)",
      "purpose": "Fixed center indicator showing current selection point"
    }
  },

  "shader_techniques": {
    "butterfly_wave_scrawler": {
      "source": "https://gl-transitions.com/editor/ButterflyWaveScrawler",
      "author": "mandubian",
      "license": "MIT",
      "modifications": [
        "Progress clamped to max 0.35 (realProgress = progress * 0.5)",
        "Custom parameters: amplitude=1.5, waves=10.0, colorSeparation=3.0"
      ],
      "algorithm": {
        "butterfly_function": "Polar function with exponential and trigonometric components",
        "formula": "exp(cos(theta)) - 2*cos(4*theta) + pow(sin((2*theta - PI)/24), 5)",
        "theta_calculation": "acos(dot(o, h)) * waves",
        "displacement": "compute(p, progress, center)",
        "wave_count": 10
      },
      "color_separation": {
        "technique": "RGB channel displacement",
        "red_channel": "getFromColor(p + realProgress * disp * (1.0 - colorSeparation))",
        "green_channel": "getFromColor(p + realProgress * disp)",
        "blue_channel": "getFromColor(p + realProgress * disp * (1.0 + colorSeparation))",
        "value": 3.0,
        "effect": "Chromatic aberration-like distortion"
      },
      "transition_mixing": {
        "formula": "texTo * realProgress + texFrom * inv",
        "inv": "1.0 - realProgress",
        "crossfade": "Linear interpolation between from and to images"
      },
      "parameters_customization": {
        "amplitude": "Controls wave intensity (1.5)",
        "waves": "Number of wave cycles (10.0)",
        "colorSeparation": "RGB offset multiplier (3.0)",
        "note": "Can be exposed as UI sliders for real-time adjustment"
      }
    },
    "shader_wrapper_pattern": {
      "function": "transition(glEffect)",
      "uniform_injection": {
        "image1": "shader (ImageShader)",
        "image2": "shader (ImageShader)",
        "progress": "float (0.0 to 1.0)",
        "resolution": "float2 [width, height]"
      },
      "helper_functions": {
        "getFromColor": "half4 getFromColor(float2 uv) { return image1.eval(uv * resolution); }",
        "getToColor": "half4 getToColor(float2 uv) { return image2.eval(uv * resolution); }"
      },
      "main_function": "vec2 uv = xy / resolution; return transition(uv);",
      "compilation": "frag`` template literal compiles with Skia.RuntimeEffect.Make",
      "error_handling": "Throws 'Couldn't Compile Shader' if compilation fails"
    },
    "dual_image_shader": {
      "pattern": "Two identical ImageShader children in Shader component",
      "current_usage": "Both render same image (for testing/demo)",
      "intended_usage": "image1 = original, image2 = filtered version",
      "fit": "cover",
      "dimensions": "width and height passed as uniforms",
      "note": "Comment suggests fit='contain' for real use cases"
    },
    "uniform_updates": {
      "pattern": "useDerivedValue for reactive shader uniforms",
      "uniforms_object": {
        "progress": "progress.value (0 to 1)",
        "resolution": "[width, height]"
      },
      "dependencies": ["width", "height"],
      "update_frequency": "Every frame when progress changes",
      "thread": "UI thread via Reanimated worklet"
    }
  },

  "donut_circular_progress": {
    "rendering": "Skia Path with Circle added via addCircle",
    "dimensions": {
      "size": 35,
      "stroke_width": 4,
      "radius": "size/2 - strokeWidth/2"
    },
    "path_generation": {
      "method": "Skia.Path.Make().addCircle()",
      "center": "[size/2, size/2]",
      "memoization": "useMemo with [radius, size] dependencies"
    },
    "rotation": {
      "transform": "rotate: -Math.PI/2",
      "origin": "{x: size/2, y: size/2}",
      "purpose": "Start progress from top (12 o'clock position)"
    },
    "layers": {
      "background": {
        "color": "rgba(255,255,255,0.25)",
        "start": 0,
        "end": 1,
        "stroke_cap": "round"
      },
      "progress": {
        "color": "SharedValue (interpolated color)",
        "start": 0,
        "end": "progress SharedValue (0 to 1)",
        "stroke_cap": "round"
      }
    },
    "color_sync": {
      "source": "Same useDerivedValue color as indicator line",
      "interpolation": "#6d9bf1 to orange based on progress",
      "binding": "Direct SharedValue reference (no intermediate state)"
    }
  },

  "reanimated_patterns": {
    "shared_values": [
      {
        "name": "progressPercentage",
        "type": "SharedValue<number>",
        "initial": 0,
        "range": "0 to 1",
        "updates": "Via onProgressChange callback from DraggableSlider",
        "scope": "App component",
        "consumers": ["ImageEditor", "DonutCircularProgress", "color interpolation"]
      },
      {
        "name": "scrollContext",
        "type": "SharedValue<number>",
        "initial": 0,
        "purpose": "Store scroll position at gesture start",
        "usage": "Reference point for calculating translationX offset",
        "scope": "DraggableSlider component"
      },
      {
        "name": "scrollOffset",
        "type": "SharedValue<number>",
        "initial": "ScreenWidth / 2",
        "updates": "During pan gesture and snap animation",
        "purpose": "Current horizontal scroll position of slider",
        "scope": "DraggableSlider component"
      }
    ],
    "useDerivedValue": {
      "usage_count": 5,
      "instances": [
        {
          "name": "color",
          "calculation": "interpolateColor(progressPercentage.value, [0,1], ['#6d9bf1', 'orange'])",
          "purpose": "Dynamic color based on progress",
          "consumers": ["DonutCircularProgress", "DraggableSlider indicator"]
        },
        {
          "name": "uniforms",
          "calculation": "{progress: progress.value, resolution: [width, height]}",
          "purpose": "Package shader uniforms",
          "dependencies": ["width", "height"]
        },
        {
          "name": "bigLinesPath",
          "calculation": "getLinesPath({...params, type: 'bigLines'})",
          "purpose": "Skia Path for big lines",
          "worklet": true
        },
        {
          "name": "smallLinesPath",
          "calculation": "getLinesPath({...params, type: 'smallLines'})",
          "purpose": "Skia Path for small lines",
          "worklet": true
        }
      ],
      "benefit": "Automatic recalculation when dependencies change, runs on UI thread"
    },
    "useAnimatedReaction": {
      "usage": "Progress calculation in DraggableSlider",
      "watching": "scrollOffset.value",
      "effect": "Interpolate offset to progress, call onProgressChange",
      "benefit": "Reactive side effect without manual tracking"
    },
    "useAnimatedStyle": {
      "usage": "Indicator line color styling",
      "calculation": "{backgroundColor: indicatorColor?.value ?? 'orange'}",
      "purpose": "React to color changes",
      "component": "Animated.View (indicator line)"
    },
    "withSpring": {
      "usage": "Snap animation for scrollOffset",
      "target": "snapPoint(scrollOffset.value, velocityX, spacings)",
      "config": { "mass": 0.45 },
      "timing": "Triggered on gesture end",
      "feel": "Light, snappy spring with low mass"
    },
    "cancelAnimation": {
      "usage": "Stop ongoing snap animation when new gesture begins",
      "target": "scrollOffset",
      "timing": "onBegin of Gesture.Pan",
      "purpose": "Allows immediate user control"
    },
    "interpolate": {
      "usage": "Scroll position to progress mapping",
      "input": "scrollOffset.value",
      "input_range": "[ScreenWidth/2, -ProgressWidth + ScreenWidth/2]",
      "output_range": "[0, 1]",
      "purpose": "Convert pixel scroll to normalized progress"
    },
    "clamp": {
      "usage": "Restrict scrollOffset within bounds",
      "min": "-ProgressWidth + ScreenWidth/2",
      "max": "ScreenWidth/2",
      "purpose": "Prevent scrolling beyond slider edges"
    }
  },

  "performance_optimizations": {
    "viewport_culling": {
      "pattern": "Skip rendering lines outside visible screen width",
      "check": "if (baseScrollView < offsetX - ScreenWidth/2 || baseScrollView > offsetX + ScreenWidth/2) continue;",
      "benefit": "Renders ~10-15 lines instead of 50+",
      "impact": "Significant reduction in path operations per frame"
    },
    "useMemo": {
      "spacings_array": {
        "calculation": "Pre-compute all snap points",
        "dependencies": ["linesAmount", "snapEach", "spacePerLine"],
        "benefit": "Avoid recalculating array on every gesture event"
      },
      "donut_path": {
        "calculation": "Skia.Path with circle",
        "dependencies": ["radius", "size"],
        "benefit": "Path object created once, reused every frame"
      },
      "shader_source": {
        "calculation": "transition(glEffect) - compiles GLSL",
        "dependencies": ["glEffect"],
        "benefit": "Expensive shader compilation happens once"
      },
      "boundary_colors": {
        "calculation": "Array of gradient colors",
        "dependencies": ["mainColor"],
        "benefit": "Prevents array recreation on every render"
      }
    },
    "useDerivedValue_over_useMemo": {
      "pattern": "Reactive calculations use useDerivedValue instead of useMemo",
      "benefit": "Runs on UI thread, updates automatically",
      "examples": ["color", "uniforms", "bigLinesPath", "smallLinesPath"]
    },
    "worklet_annotations": {
      "locations": [
        "onProgressChange callback",
        "getLinesPath function",
        "isBigLine helper",
        "snapPoint function",
        "useAnimatedReaction effect"
      ],
      "benefit": "Code runs on UI thread without JS bridge crossing",
      "performance": "Critical for 60fps gesture handling"
    },
    "path_separation": {
      "trade_off": "Two separate paths (bigLines, smallLines) vs one with conditionals",
      "cost": "Two Path components rendered",
      "benefit": "Different opacity/color without per-line logic",
      "note": "Could be optimized but acceptable for 50 lines"
    },
    "memo_on_boundary_gradient": {
      "pattern": "React.memo() on BoundaryGradient component",
      "benefit": "Prevents re-renders when parent updates",
      "props": "Static except mainColor"
    },
    "single_canvas": {
      "pattern": "All lines rendered in single Canvas",
      "benefit": "One Skia rendering context instead of 50+ Views",
      "vs_alternative": "50 individual animated Views would be significantly slower"
    }
  },

  "use_cases": {
    "primary": [
      "Photo editing apps (brightness, contrast, saturation sliders)",
      "Video editing timeline scrubbers",
      "Audio level adjustments with visual feedback",
      "Filter intensity controls",
      "Color grading interfaces",
      "Image comparison tools (before/after slider)"
    ],
    "secondary": [
      "Custom range inputs with snap points",
      "Timeline navigation with markers",
      "Volume controls with visual levels",
      "Zoom level selectors",
      "Progress indicators for media playback",
      "Measurement tools (rulers, scales)"
    ],
    "design_contexts": [
      "Creative tools and editors",
      "Professional editing applications",
      "Media consumption apps",
      "Camera and photography apps",
      "Music production interfaces",
      "Design system showcases"
    ],
    "real_world_inspiration": [
      "Prequel app filter sliders",
      "VSCO editing interface",
      "Instagram filter controls",
      "Lightroom mobile adjustments",
      "Photo editing apps on iOS/Android"
    ],
    "not_recommended_for": [
      "Simple value selection (overkill)",
      "High-frequency updates (shader can be expensive)",
      "Accessibility-first interfaces (limited screen reader support)",
      "Web-only applications (Skia WASM overhead)"
    ]
  },

  "code_quality": {
    "typescript": {
      "coverage": "Full TypeScript with explicit types",
      "type_definitions": [
        "DraggableSliderProps",
        "ImageEditorProps",
        "DonutCircularProgressProps",
        "BoundaryGradientProps",
        "Transition"
      ],
      "type_imports": "Type-only imports with 'type' keyword",
      "utility_types": "Omit<CanvasProps, 'children'>",
      "type_safety": "SharedValue<number>, SkImage types properly used"
    },
    "documentation": {
      "inline_comments": "Excellent - detailed explanations throughout",
      "prop_descriptions": {
        "examples": [
          "// Total number of lines in the slider",
          "// Optional: Indicates how frequently snapping should occur",
          "// Height of the scrollable area - You may want to set this to increase the touchable area"
        ]
      },
      "algorithm_explanations": [
        "Viewport culling optimization explained",
        "Snap point calculation documented",
        "Shader source attribution with URLs"
      ],
      "author_notes": [
        "I used a remote image from Unsplash... But I recommend you to use a local image",
        "There are definitely better ways of doing that :)",
        "I really love this function from reanimated because it's so easy to use",
        "Few years ago I made a YouTube tutorial about it",
        "Try to set it to 5 to see the difference",
        "Maybe for real use cases, you would want to use the fit='contain' prop"
      ],
      "external_references": [
        "https://gl-transitions.com/editor/ButterflyWaveScrawler",
        "https://youtu.be/PzKWpwmmRqM (William Candillon)",
        "https://youtu.be/U_V9pHnTXjA (Interpolate Colors tutorial)",
        "https://github.com/wcandillon/react-native-redash (snapPoint function)",
        "https://github.com/Shopify/react-native-skia (Skia examples)"
      ]
    },
    "code_organization": {
      "separation_of_concerns": "Clear component/utils/transitions structure",
      "component_isolation": "Each component in its own directory",
      "utility_extraction": "Reusable functions in utils directories",
      "constants": "Screen width and other constants properly extracted",
      "barrel_exports": "Index files for clean imports"
    },
    "best_practices": [
      "useMemo for expensive calculations (paths, arrays)",
      "useDerivedValue for reactive UI thread calculations",
      "useAnimatedReaction for side effects",
      "Worklet annotations for performance",
      "Proper gesture lifecycle handling (onBegin, onUpdate, onEnd)",
      "cancelAnimation before new gesture",
      "Clamping values to prevent out-of-bounds",
      "Viewport culling for rendering optimization"
    ],
    "strengths": [
      "Well-documented with helpful comments",
      "Performance-conscious implementation",
      "Clean separation of components",
      "Proper TypeScript usage",
      "Educational comments for learning",
      "Attribution for borrowed code (snapPoint)",
      "Modular shader system"
    ],
    "areas_for_improvement": [
      "Hardcoded constants (Lines=50, SpacePerLine=10) could be props",
      "Remote image URL could be prop or require() for reliability",
      "Magic numbers in calculations (safeBottom * 3)",
      "Could extract constants to separate file",
      "Optional: Add error boundary for shader compilation failures",
      "Could add accessibility labels and hints",
      "Type for shader transition could be more specific"
    ]
  },

  "known_limitations": {
    "shader_usage": {
      "current_implementation": "Both ImageShaders use same image",
      "limitation": "Not demonstrating actual transition between different images",
      "intended_usage": "image1 = original, image2 = filtered version",
      "impact": "Shader effect visible but not fully functional demo",
      "note": "Comment in code acknowledges this"
    },
    "progress_clamping": {
      "shader_limitation": "ButterflyWaveScrawler progress clamped to 0.5 (realProgress = progress * 0.5)",
      "reason": "Full progress range may create excessive distortion",
      "customization": "Parameters (amplitude, waves, colorSeparation) are hardcoded",
      "improvement": "Could expose as slider controls for real-time adjustment"
    },
    "remote_image": {
      "issue": "Uses Unsplash URL for demo image",
      "risks": [
        "Network dependency",
        "Potential rate limiting",
        "Image could be removed",
        "Slower loading time"
      ],
      "author_note": "I recommend you to use a local image for better performance and reliability",
      "workaround": "Replace with require() for production"
    },
    "fixed_configuration": {
      "hardcoded_values": [
        "50 lines",
        "10px space per line",
        "12px max line height",
        "5px min line height",
        "2px line width",
        "Every 10th line is big"
      ],
      "customization": "Limited without modifying source",
      "improvement": "Could expose as props or config object"
    },
    "calculation_complexity": {
      "image_editor_sizing": {
        "formula": "windowWidth * 0.95 and windowHeight * 0.9 - safeBottom * 3 - safeTop",
        "issue": "safeBottom * 3 is magic number",
        "comment": "There are definitely better ways of doing that :)",
        "improvement": "More explicit layout calculations"
      }
    },
    "accessibility": {
      "screen_readers": "No accessibility labels or hints",
      "keyboard_navigation": "No keyboard support",
      "reduced_motion": "Animations always active",
      "value_announcements": "No announcements of progress changes",
      "semantic_roles": "Missing role and state information"
    },
    "path_rendering": {
      "optimization_opportunity": "Rendering big/small lines in separate paths",
      "trade_off": "Simplicity and opacity control vs potential optimization",
      "note": "Author acknowledges: 'I'm not sure if this can be optimized further'",
      "impact": "Minimal with viewport culling, acceptable for 50 lines"
    }
  },

  "potential_improvements": {
    "configuration": [
      "Make line count, spacing, heights configurable via props",
      "Expose shader parameters as adjustable controls",
      "Configurable snap intervals and spring physics",
      "Custom color schemes/gradients",
      "Adjustable boundary gradient intensity",
      "Custom indicator styles"
    ],
    "functionality": [
      "Support actual image transitions (before/after)",
      "Multiple shader presets with selector",
      "Value labels at intervals (0%, 50%, 100%)",
      "Haptic feedback at snap points",
      "Double-tap to reset to center",
      "Pinch gesture for zoom on image",
      "Long-press for context menu (reset, presets)"
    ],
    "visual_enhancements": [
      "Animated transitions when changing shaders",
      "Glow effect on indicator line",
      "Particle effects at snap points",
      "Shadow on circular progress indicator",
      "Gradient backgrounds",
      "Custom fonts for any text displays"
    ],
    "performance": [
      "Precompile shaders at app start",
      "Lower shader quality option for low-end devices",
      "Lazy image loading with placeholder",
      "Reduce blur/sample counts for better performance",
      "Add FPS monitoring in dev mode"
    ],
    "developer_experience": [
      "Export as standalone npm package",
      "Storybook/documentation site",
      "Interactive playground for parameters",
      "TypeScript types for all shader uniforms",
      "Hot-reload shader development",
      "More shader presets out of the box"
    ],
    "accessibility": [
      "Add accessibility labels and hints",
      "Screen reader support for progress values",
      "Keyboard navigation",
      "Respect reduced motion preferences",
      "High contrast mode support",
      "Voice control integration"
    ],
    "code_quality": [
      "Extract magic numbers to constants",
      "Use local images by default",
      "Add error boundaries",
      "Improve image editor sizing calculations",
      "Add PropTypes or Zod validation",
      "Unit tests for utility functions"
    ]
  },

  "key_insights": {
    "viewport_culling_importance": "Rendering only visible lines (10-15 instead of 50) is crucial optimization for smooth performance",
    "snap_point_physics": "react-native-redash snapPoint algorithm with velocity consideration creates natural feel",
    "path_based_rendering": "Using Skia Path for lines is far more efficient than individual Views",
    "shader_wrapper_elegance": "transition() wrapper injecting uniforms allows any gl-transitions.com shader to work",
    "color_sync_pattern": "Single useDerivedValue color shared across multiple components creates cohesive visual feedback",
    "worklet_critical": "Worklet annotations throughout ensure 60fps gesture handling on UI thread",
    "gesture_lifecycle": "Proper onBegin/onUpdate/onEnd with cancelAnimation prevents animation conflicts",
    "clamping_pattern": "clamp() in onUpdate prevents edge cases and ensures bounded movement",
    "dual_image_shader": "Two ImageShader children enable transition effects, currently underutilized in demo",
    "educational_comments": "Author's personal notes and references make code highly educational"
  },

  "learning_opportunities": {
    "for_beginners": [
      "Basic Skia rendering (Canvas, Path, Circle)",
      "SharedValue for reactive state",
      "Simple gesture handling with Gesture.Pan",
      "Interpolation basics",
      "Color interpolation with interpolateColor",
      "Safe area insets usage"
    ],
    "for_intermediate": [
      "Path-based rendering for performance",
      "useDerivedValue for reactive calculations",
      "useAnimatedReaction for side effects",
      "Gesture lifecycle (onBegin/onUpdate/onEnd)",
      "Snap points with velocity consideration",
      "Viewport culling optimization",
      "Spring animations with withSpring",
      "Clamping and boundary handling"
    ],
    "for_advanced": [
      "GLSL shader programming",
      "Shader uniform systems",
      "GPU-accelerated image effects",
      "Complex path generation algorithms",
      "Worklet optimization techniques",
      "Custom slider implementations",
      "Performance profiling and optimization",
      "gl-transitions.com shader porting",
      "Color separation techniques",
      "Butterfly polar functions in shaders"
    ]
  },

  "comparison_to_alternatives": {
    "vs_native_slider": {
      "native": "Platform-specific, basic thumb and track",
      "this": "Fully custom visual design with lines, shader effects, circular progress",
      "customization": "This implementation infinitely more customizable",
      "complexity": "Higher complexity but unique visual identity"
    },
    "vs_scrubber_components": {
      "libraries": "react-native-scrubber, react-native-slider",
      "this": "Integrated shader effects and line-based UI",
      "use_case": "This is specialized for photo/video editing context",
      "visual_impact": "Much more visually impressive"
    },
    "vs_timeline_scrubbers": {
      "typical": "Waveform or thumbnail preview",
      "this": "Abstract line pattern with shader feedback",
      "focus": "This emphasizes visual effect, not content preview",
      "aesthetic": "More artistic than practical"
    }
  },

  "real_world_inspiration": {
    "prequel_app": "iOS photo editing app with similar slider aesthetics",
    "vsco": "Line-based slider controls for filters",
    "lightroom_mobile": "Slider with snap points and visual feedback",
    "instagram_filters": "Intensity sliders with real-time preview",
    "photo_editing_apps": "Common pattern in creative tools"
  },

  "technical_challenges_and_solutions": {
    "viewport_culling": {
      "challenge": "Rendering 50+ lines every frame causes performance issues",
      "solution": "Calculate baseScrollView and skip lines outside ScreenWidth bounds",
      "result": "Only 10-15 lines rendered at any time",
      "trade_off": "Slight calculation overhead vs massive rendering savings"
    },
    "snap_physics": {
      "challenge": "Natural feeling snap behavior with velocity consideration",
      "solution": "Use react-native-redash snapPoint with velocity multiplier",
      "formula": "point = value + 0.2 * velocity",
      "benefit": "Snaps to nearest point considering fling direction"
    },
    "shader_integration": {
      "challenge": "Making arbitrary gl-transitions.com shaders work",
      "solution": "transition() wrapper injects uniform boilerplate",
      "pattern": "Template literal composition",
      "result": "Any GLSL transition shader can be dropped in"
    },
    "color_synchronization": {
      "challenge": "Multiple UI elements need same dynamic color",
      "solution": "Single useDerivedValue with interpolateColor, passed as SharedValue",
      "benefit": "All elements react automatically, no manual updates"
    },
    "gesture_boundaries": {
      "challenge": "Prevent scrolling beyond slider edges",
      "solution": "clamp() in onUpdate with calculated min/max bounds",
      "edge_case": "ScreenWidth/2 centering for proper edge handling"
    },
    "path_generation_performance": {
      "challenge": "Recalculating path every frame is expensive",
      "solution": "useDerivedValue ensures recalculation only when dependencies change",
      "optimization": "Viewport culling reduces path complexity"
    }
  },

  "performance_metrics": {
    "target_fps": 60,
    "expected_performance": "Smooth on mid-range devices",
    "gpu_acceleration": "All Skia rendering GPU-accelerated",
    "ui_thread_execution": "Gestures and calculations on UI thread via worklets",
    "critical_path": [
      "Pan gesture onUpdate",
      "scrollOffset update",
      "useAnimatedReaction triggers progress calculation",
      "useDerivedValue recalculates paths and color",
      "Skia renders updated paths"
    ],
    "bottlenecks": [
      "Shader complexity (butterfly polar function with color separation)",
      "Path generation with 50 lines (mitigated by viewport culling)",
      "Remote image loading (use local images for production)"
    ],
    "optimizations_impact": {
      "viewport_culling": "~70% reduction in path operations",
      "useMemo_for_spacings": "Eliminates array creation on every gesture event",
      "worklet_annotations": "Eliminates JS bridge crossing (~16ms saved per frame)",
      "path_separation": "Minor cost but acceptable trade-off"
    }
  },

  "platform_considerations": {
    "ios": {
      "features": "All features fully supported",
      "performance": "Excellent - Metal backend for Skia",
      "gestures": "Native pan gesture handling"
    },
    "android": {
      "features": "All features fully supported",
      "performance": "Excellent - Vulkan backend for Skia",
      "gestures": "Native pan gesture handling",
      "considerations": "Test on various Android devices for shader performance"
    },
    "web": {
      "compatibility": "Skia uses CanvasKit on web",
      "performance": "Good but WASM overhead",
      "bundle_size": "CanvasKit adds significant size (~2-3MB)",
      "gestures": "Mouse events work but less natural than touch"
    }
  },

  "bundle_size_impact": {
    "component_code": "~700 lines total across all files",
    "dependencies": [
      "@shopify/react-native-skia (likely already in project)",
      "react-native-reanimated (likely already in project)",
      "react-native-gesture-handler (likely already in project)"
    ],
    "new_dependencies": "None if Skia/Reanimated already present",
    "shader_code": "~50 lines GLSL (minimal)",
    "assets": "Demo image (recommend local asset)",
    "estimated_addition": "~5KB code + dependencies if not present"
  },

  "testing_considerations": {
    "visual_tests": [
      "Verify line rendering at different scroll positions",
      "Check boundary gradient fades properly",
      "Confirm indicator line stays centered",
      "Verify circular progress matches slider position",
      "Check color interpolation smoothness",
      "Test shader effect renders correctly"
    ],
    "interaction_tests": [
      "Drag slider across full range",
      "Verify snap behavior at various velocities",
      "Test rapid back-and-forth gestures",
      "Confirm clamping at edges",
      "Test interrupting snap animation with new gesture",
      "Verify progress callback fires correctly"
    ],
    "edge_cases": [
      "Very fast fling gestures",
      "Edge-to-edge dragging",
      "Rapid mounting/unmounting",
      "Screen rotation during gesture",
      "Different screen sizes (small phones to tablets)",
      "Missing/failed image loading"
    ],
    "performance_tests": [
      "Measure FPS during continuous dragging",
      "Monitor GPU usage with shader active",
      "Test on low-end devices",
      "Profile path generation timing",
      "Check memory usage over time"
    ]
  },

  "accessibility_considerations": {
    "current_state": "No accessibility support",
    "recommendations": [
      "Add accessibilityRole='slider' to gesture detector",
      "Implement accessibilityValue with min/max/now",
      "Add accessibilityLabel describing the slider purpose",
      "Support increment/decrement actions for screen readers",
      "Announce progress value changes",
      "Provide keyboard navigation (arrow keys)",
      "Respect reduced motion preferences (disable shader, spring)",
      "Add focus indicators",
      "Consider haptic feedback at snap points"
    ],
    "implementation_effort": "Medium - requires wrapper with accessibility props and alternative interaction methods"
  },

  "related_patterns": {
    "photo_editing_sliders": "Filter intensity and adjustment controls",
    "timeline_scrubbers": "Video/audio timeline navigation",
    "range_selectors": "Value selection with visual feedback",
    "shader_previews": "Real-time GPU effect visualization",
    "snap_point_sliders": "Discrete value selection with physics"
  },

  "tags": [
    "slider",
    "photo-editing",
    "glsl",
    "shader",
    "skia",
    "draggable",
    "snap-points",
    "gesture",
    "path-rendering",
    "circular-progress",
    "color-interpolation",
    "gpu-accelerated",
    "worklets",
    "viewport-culling",
    "spring-animation",
    "butterfly-wave",
    "image-shader",
    "prequel",
    "creative-tools",
    "reanimated"
  ]
}
