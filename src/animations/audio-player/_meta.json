{
  "animation_name": "Audio Player",
  "animation_slug": "audio-player",
  "description": "An interactive audio waveform scrubber with gesture-driven playback control. Features a dynamic waveform visualization with 50 normalized samples, pan gesture for scrubbing, automatic playback animation with linear timing, and real-time current time display. Samples scale and change opacity based on playback position and user interaction, creating an engaging audio player interface with smooth spring animations.",

  "main_features": [
    "Interactive waveform scrubber with pan gesture",
    "50 normalized waveform samples from generated audio data",
    "Automatic playback animation with 22-second duration",
    "Dynamic sample scaling based on proximity to playback head",
    "Opacity changes for active vs inactive samples",
    "Real-time current time display with zero-padded formatting",
    "Gesture-based scrubbing with position tracking",
    "Automatic animation continuation after gesture release",
    "Individual sample animations with spring timing",
    "Waveform generation from sine wave at 440Hz frequency"
  ],

  "file_structure": {
    "index.tsx": "Main AudioPlayer component with GestureHandlerRootView wrapper",
    "components/waveform-scrubber/index.tsx": "WaveformScrubber component managing layout, gestures, and time display",
    "components/waveform-scrubber/waveform-sample/index.tsx": "Individual WaveformScrubberSample with scale and opacity animations",
    "components/waveform-scrubber/waveform-sample/use-current-playing-value.ts": "Custom hook managing playback position, gesture handling, and animation state",
    "constants.ts": "Palette colors, waveform sample data, and duration constant",
    "helpers/index.ts": "Barrel export for helper functions",
    "helpers/generate-waveform.ts": "Generates sine wave audio samples",
    "helpers/normalize-array.ts": "Normalizes array values to 0-1 range",
    "helpers/pick-n-values-from-array.ts": "Samples N values from array using normal distribution",
    "helpers/zero-pad.ts": "Pads numbers with leading zeros for time display"
  },

  "core_technologies": {
    "animations": "react-native-reanimated",
    "gestures": "react-native-gesture-handler",
    "text": "react-native-redash (ReText)"
  },

  "packages_and_versions": {
    "react-native-reanimated": {
      "version": "~4.1.1",
      "hooks": [
        "useSharedValue",
        "useAnimatedStyle",
        "useDerivedValue",
        "useAnimatedReaction"
      ],
      "functions": [
        "withTiming",
        "cancelAnimation",
        "Easing"
      ],
      "components": ["Animated.View"],
      "critical_feature": "useAnimatedReaction for gesture-to-animation coordination and automatic playback continuation"
    },
    "react-native-gesture-handler": {
      "version": "~2.28.0",
      "components": ["GestureDetector", "GestureHandlerRootView"],
      "gestures": ["Gesture.Pan()"],
      "methods": ["onBegin", "onUpdate", "onFinalize"],
      "usage": "Pan gesture for waveform scrubbing interaction"
    },
    "react-native-redash": {
      "version": "Latest",
      "components": ["ReText"],
      "usage": "Animated text component for current time display without re-renders",
      "benefit": "Updates text directly from SharedValue without bridge crossing"
    }
  },

  "animation_techniques": {
    "automatic_playback": {
      "pattern": "Linear timing animation from 0 to waveform width",
      "implementation": "withTiming(waveformContentWidth, { duration: DURATION * 1000, easing: Easing.linear })",
      "duration": "22 seconds (22000ms)",
      "easing": "Easing.linear (constant speed)",
      "trigger": "useEffect on component mount",
      "effect": "Playback head moves steadily from left to right across waveform"
    },
    "gesture_scrubbing": {
      "gesture": "Gesture.Pan()",
      "lifecycle": {
        "onBegin": "Stores current touch position, sets isDragging to true",
        "onUpdate": "Updates touchedX with event.x position",
        "onFinalize": "Sets isDragging to false, triggers animation restart"
      },
      "cancellation": "cancelAnimation(currentX) when gesture starts",
      "continuation": "Calculates remaining duration and resumes animation from current position"
    },
    "sample_scale_animation": {
      "pattern": "Dynamic scale based on playback position and gesture state",
      "conditions": [
        "Not dragging: scaleY = 1 (neutral)",
        "Dragging + near current position + active: scaleY = 1.4 (emphasized)",
        "Dragging + active but not near: scaleY = 0.9 (slightly compressed)",
        "Dragging + inactive: scaleY = 0.7 (de-emphasized)"
      ],
      "proximity_threshold": "20px from currentX position",
      "timing": "withTiming for smooth scale transitions",
      "effect": "Sample closest to playback head scales up, creating focus point"
    },
    "sample_opacity_animation": {
      "pattern": "Binary opacity based on active state",
      "active_sample": "opacity: 1 (currentX > sample position)",
      "inactive_sample": "opacity: 0.6 (currentX <= sample position)",
      "timing": "withTiming for smooth fade",
      "effect": "Visual distinction between played and unplayed portions"
    },
    "playback_continuation": {
      "pattern": "useAnimatedReaction monitoring isDragging state changes",
      "detection": "When isDragging changes from true to false",
      "calculation": "remainingSeconds = DURATION * (1 - currentX / waveformContentWidth)",
      "animation": "withTiming(waveformContentWidth, { duration: remainingSeconds * 1000, easing: Easing.linear })",
      "effect": "Seamless playback continuation from scrubbed position"
    },
    "position_tracking": {
      "pattern": "useAnimatedReaction watching touchedX changes",
      "condition": "Only updates when isDragging is true and touchedX changed",
      "action": "cancelAnimation(currentX), then set currentX = touchedX",
      "effect": "Playback head follows touch position in real-time during gesture"
    },
    "time_display_formatting": {
      "pattern": "useDerivedValue calculating formatted time string",
      "calculation": "(currentX / waveformContentWidth) * DURATION",
      "formatting": "'0:' + zeroPad(Math.min(Math.floor(seconds), DURATION), 2)",
      "clamping": "Math.min ensures time never exceeds DURATION",
      "component": "ReText for bridge-free text updates",
      "effect": "Real-time time display updates smoothly without re-renders"
    }
  },

  "reanimated_patterns": {
    "shared_values": [
      {
        "name": "touchedX",
        "type": "SharedValue<number>",
        "initial": 0,
        "scope": "useCurrentPlayingValue hook",
        "updates": "Pan gesture onBegin and onUpdate",
        "purpose": "Tracks current touch X position during gesture"
      },
      {
        "name": "isDragging",
        "type": "SharedValue<boolean>",
        "initial": false,
        "scope": "useCurrentPlayingValue hook",
        "updates": "onBegin sets true, onFinalize sets false",
        "purpose": "Indicates active gesture state, controls animation behavior"
      },
      {
        "name": "currentX",
        "type": "SharedValue<number>",
        "initial": 0,
        "scope": "useCurrentPlayingValue hook",
        "updates": "Automatic animation or gesture-driven",
        "purpose": "Current playback head position, drives all visualizations",
        "animations": "withTiming for automatic playback and continuation"
      }
    ],
    "derived_values": [
      {
        "name": "currentTime",
        "scope": "WaveformScrubber component",
        "calculation": "'0:' + zeroPad(Math.min(Math.floor((currentX / waveformContentWidth) * DURATION), DURATION), 2)",
        "dependencies": ["currentX", "waveformContentWidth", "DURATION"],
        "purpose": "Formatted time string for ReText display",
        "output_format": "0:XX (e.g., '0:05', '0:22')"
      },
      {
        "name": "scaleY (within getNextScaleY)",
        "scope": "WaveformScrubberSample component",
        "calculation": "Conditional based on isDragging, isActive, isNearCurrentX",
        "dependencies": ["isDragging", "currentX", "sample position"],
        "purpose": "Dynamic scale value for each sample",
        "worklet": true
      }
    ],
    "useAnimatedReaction_instances": [
      {
        "name": "Touch position watcher",
        "watches": "touchedX.value",
        "callback": "Cancel animation and set currentX = touchedX when dragging",
        "condition": "Only acts if isDragging.value is true and touchedX changed",
        "purpose": "Synchronize playback head with touch position during gesture",
        "location": "useCurrentPlayingValue hook (lines 61-76)"
      },
      {
        "name": "Gesture state watcher",
        "watches": "isDragging.value",
        "callback": "Restart animation when gesture ends",
        "calculation": "remainingSeconds = DURATION * (1 - currentX / waveformContentWidth)",
        "animation": "withTiming(waveformContentWidth, { duration: remainingSeconds * 1000, easing: Easing.linear })",
        "purpose": "Continue playback animation after scrubbing",
        "location": "useCurrentPlayingValue hook (lines 78-102)"
      }
    ],
    "useAnimatedStyle_instances": [
      {
        "name": "rStyle",
        "target": "WaveformScrubberSample",
        "properties": [
          "opacity (withTiming based on isActive)",
          "transform[scaleY] (withTiming based on getNextScaleY result)"
        ],
        "calculations": [
          "isActive = currentX.value > position",
          "isNearCurrentX = Math.abs(currentX.value - position) < 20",
          "scaleY = getNextScaleY({ isDragging, isActive, isNearCurrentX })"
        ],
        "purpose": "Animate individual sample appearance based on playback state"
      }
    ],
    "cancelAnimation_usage": {
      "location": "useAnimatedReaction (touchedX watcher)",
      "pattern": "cancelAnimation(currentX) before setting new value",
      "purpose": "Stop automatic playback when user starts scrubbing",
      "critical_for": "Responsive gesture interaction without animation conflicts"
    },
    "worklet_functions": [
      {
        "name": "getNextScaleY",
        "signature": "({ isDragging, isActive, isNearCurrentX }) => number",
        "directive": "'worklet'",
        "purpose": "Calculate scale value based on multiple conditions",
        "returns": "1.4, 1, 0.9, or 0.7 depending on state",
        "location": "waveform-sample/index.tsx (lines 28-48)"
      },
      {
        "name": "zeroPad",
        "signature": "(num: number, places: number) => string",
        "directive": "'worklet'",
        "purpose": "Pad number with leading zeros",
        "implementation": "String(num).padStart(places, '0')",
        "usage": "Time display formatting",
        "location": "helpers/zero-pad.ts"
      }
    ]
  },

  "gesture_handling": {
    "pan_gesture_configuration": {
      "type": "Gesture.Pan()",
      "events": {
        "onBegin": [
          "touchedX.value = event.x",
          "isDragging.value = true"
        ],
        "onUpdate": [
          "touchedX.value = event.x"
        ],
        "onFinalize": [
          "isDragging.value = false"
        ]
      },
      "no_options": "Default pan gesture configuration",
      "purpose": "Track horizontal touch position for scrubbing"
    },
    "gesture_animation_coordination": {
      "pattern": "useAnimatedReaction bridges gesture state to animation state",
      "flow": [
        "1. User touches waveform",
        "2. onBegin sets isDragging = true, stores touch position",
        "3. useAnimatedReaction (touchedX) detects change, cancels animation",
        "4. onUpdate continuously updates touchedX",
        "5. useAnimatedReaction (touchedX) updates currentX to follow touch",
        "6. Samples animate based on new currentX position",
        "7. onFinalize sets isDragging = false",
        "8. useAnimatedReaction (isDragging) detects change, restarts animation from current position"
      ],
      "key_insight": "Separate SharedValues for touch position and playback position enable smooth transitions"
    }
  },

  "component_architecture": {
    "AudioPlayer": {
      "type": "Main component",
      "wrapper": "GestureHandlerRootView (required for gesture handling)",
      "structure": "View container > WaveformScrubber",
      "styling": "Centered layout with Palette.background",
      "purpose": "Entry point component with gesture context"
    },
    "WaveformScrubber": {
      "type": "Container component",
      "props": {
        "waveformSamples": {
          "type": "number[]",
          "description": "Array of normalized waveform values (0-1 range)",
          "length": "50 samples"
        }
      },
      "responsibilities": [
        "Calculate responsive waveform dimensions",
        "Manage pan gesture with useCurrentPlayingValue hook",
        "Display current time and total duration",
        "Render sample components with position mapping"
      ],
      "dimensions": {
        "waveformScrubberWidth": "screenWidth * 0.95",
        "waveformPaddingHorizontal": 20,
        "waveformContentWidth": "waveformScrubberWidth - waveformPaddingHorizontal"
      }
    },
    "WaveformScrubberSample": {
      "type": "Presentational component",
      "optimization": "memo() for performance",
      "props": {
        "position": "number (horizontal position in pixels)",
        "currentX": "SharedValue<number> (playback head position)",
        "isDragging": "SharedValue<boolean> (gesture state)",
        "value": "number (normalized sample height 0-1)"
      },
      "responsibilities": [
        "Render individual waveform bar",
        "Calculate active state (played/unplayed)",
        "Calculate proximity to playback head",
        "Animate scale and opacity based on state"
      ],
      "design": {
        "width": "3px",
        "maxHeight": "45px (scaled by value)",
        "minHeight": "4.5px (45 * 0.1 for value = 0)",
        "borderRadius": "15px",
        "backgroundColor": "Palette.body (#D4D4D4)"
      }
    },
    "useCurrentPlayingValue": {
      "type": "Custom hook",
      "params": {
        "waveformContentWidth": "number (available width for animation)"
      },
      "returns": {
        "panGesture": "Gesture.Pan() instance",
        "currentX": "SharedValue<number> (playback position)",
        "isDragging": "SharedValue<boolean> (gesture state)"
      },
      "responsibilities": [
        "Initialize automatic playback animation",
        "Create and configure pan gesture",
        "Handle gesture-animation transitions",
        "Calculate remaining playback time on gesture end",
        "Restart animation from scrubbed position"
      ],
      "key_feature": "Seamless switching between automatic and manual playback"
    }
  },

  "mathematical_algorithms": {
    "waveform_generation": {
      "function": "generateWaveform(sampleRate, frequency, duration)",
      "sample_rate": "44100 Hz (CD quality)",
      "frequency": "440 Hz (A4 musical note)",
      "duration": "22.0 seconds",
      "formula": "Math.sin(2 * Math.PI * frequency * t)",
      "output": "Array of 970,200 samples (44100 * 22)",
      "purpose": "Generate realistic audio waveform data"
    },
    "value_picking": {
      "function": "pickNValuesFromArray(arr, N)",
      "algorithm": "Box-Muller transform for normal distribution",
      "N_samples": "50 values",
      "input": "970,200 waveform samples",
      "output": "50 representative samples",
      "purpose": "Reduce large sample set to displayable count while maintaining waveform shape",
      "note": "Uses statistical sampling to preserve waveform characteristics"
    },
    "normalization": {
      "function": "normalizeArray(arr)",
      "formula": "(value - minValue) / (maxValue - minValue)",
      "input_range": "[-1, 1] (sine wave output)",
      "output_range": "[0, 1]",
      "purpose": "Convert audio samples to visual heights",
      "result": "All values in 0-1 range for consistent display"
    },
    "position_calculation": {
      "formula": "(waveformContentWidth / waveformSamples.length) * i",
      "purpose": "Calculate horizontal position for each sample",
      "example": "width=380px, samples=50 => spacing = 7.6px per sample"
    },
    "progress_calculation": {
      "formula": "(currentX.value / waveformContentWidth) * DURATION",
      "input": "currentX position in pixels",
      "output": "Seconds elapsed",
      "example": "currentX=190, width=380, duration=22 => 11 seconds"
    },
    "remaining_time_calculation": {
      "formula": "DURATION * (1 - currentX.value / waveformContentWidth)",
      "purpose": "Calculate time remaining for animation continuation",
      "use_case": "Resume playback from scrubbed position"
    }
  },

  "visual_design": {
    "color_palette": {
      "primary": "#474069 (dark purple)",
      "body": "#D4D4D4 (light gray)",
      "background": "#1D1B2B (dark blue-purple)",
      "purpose": "Dark theme audio player aesthetic"
    },
    "waveform_styling": {
      "container": {
        "backgroundColor": "Palette.primary",
        "borderRadius": "15px",
        "height": "80px",
        "paddingHorizontal": "18px",
        "flexDirection": "row"
      },
      "sample": {
        "width": "3px",
        "maxHeight": "45px",
        "minHeight": "4.5px (10% of maxHeight)",
        "borderRadius": "15px",
        "backgroundColor": "Palette.body"
      },
      "layout": "Samples evenly distributed across width with flex: 1 containers"
    },
    "time_display": {
      "container": {
        "aspectRatio": "16 / 9",
        "backgroundColor": "Palette.primary",
        "borderRadius": "10px",
        "height": "35px",
        "marginBottom": "15px"
      },
      "text": {
        "color": "Palette.body",
        "fontSize": "14px",
        "fontWeight": "700"
      },
      "layout": "Current time (left) and total duration (right)"
    },
    "responsive_design": {
      "hook": "useWindowDimensions()",
      "waveform_width": "95% of screen width",
      "adaptation": "Samples scale and distribute based on available width"
    }
  },

  "state_management": {
    "playback_lifecycle": {
      "initial_load": [
        "1. Component mounts",
        "2. useEffect triggers",
        "3. currentX.value = withTiming(waveformContentWidth, 22000ms, linear)",
        "4. Playback head animates from 0 to full width over 22 seconds"
      ],
      "user_scrubbing": [
        "1. User touches waveform",
        "2. onBegin sets isDragging = true, stores touch position",
        "3. useAnimatedReaction (touchedX) cancels automatic animation",
        "4. onUpdate continuously updates touchedX",
        "5. useAnimatedReaction (touchedX) updates currentX = touchedX",
        "6. Playback head follows finger position",
        "7. Samples scale and change opacity based on new position"
      ],
      "scrub_release": [
        "1. onFinalize sets isDragging = false",
        "2. useAnimatedReaction (isDragging) detects change",
        "3. Calculate remainingSeconds based on current position",
        "4. currentX.value = withTiming(waveformContentWidth, remainingSeconds * 1000, linear)",
        "5. Playback continues from scrubbed position to end"
      ]
    },
    "sample_animation_state": {
      "continuous": "All samples continuously monitor currentX via useAnimatedStyle",
      "reactive": "Each sample recalculates isActive and isNearCurrentX on every frame",
      "optimized": "memo() prevents re-renders, only animated styles update",
      "independent": "Each sample animates independently based on shared currentX"
    }
  },

  "performance_optimizations": {
    "memo_components": {
      "WaveformScrubberSample": "memo() prevents re-renders when unrelated samples change",
      "benefit": "50 samples, each only re-renders when its own calculations change",
      "critical_for": "Smooth 60fps animation with many samples"
    },
    "worklet_execution": {
      "pattern": "All animation logic in worklets (useAnimatedStyle, getNextScaleY)",
      "benefit": "No bridge crossing for per-frame calculations",
      "runs_on": "UI thread",
      "result": "Responsive gesture handling and smooth animations"
    },
    "retext_optimization": {
      "component": "ReText for current time display",
      "benefit": "Text updates directly from SharedValue without React re-renders",
      "comparison": "Regular Text would cause component re-render on every frame",
      "performance_gain": "Eliminates 60 re-renders per second during playback"
    },
    "gesture_optimization": {
      "pattern": "Pan gesture runs entirely on UI thread",
      "benefit": "No JS thread communication during gesture",
      "result": "Immediate, responsive scrubbing interaction"
    },
    "animation_timing": {
      "automatic_playback": "Single withTiming animation, not per-frame updates",
      "sample_animations": "Individual withTiming calls, GPU-accelerated",
      "benefit": "Minimal CPU usage for smooth continuous animation"
    },
    "sample_reduction": {
      "original_samples": "970,200 audio samples",
      "displayed_samples": "50 visual samples",
      "reduction": "99.995% reduction in render complexity",
      "algorithm": "Statistical sampling preserves waveform shape",
      "benefit": "Manageable component count for smooth rendering"
    }
  },

  "use_cases": {
    "primary": [
      "Music player interfaces",
      "Audio recording apps",
      "Podcast players",
      "Voice memo playback",
      "Audio editing preview"
    ],
    "real_world_examples": [
      "Spotify playback scrubber",
      "Apple Music waveform",
      "SoundCloud waveform player",
      "Voice memo apps",
      "Audio editing software previews"
    ],
    "educational": [
      "Teaching gesture-animation coordination",
      "Demonstrating useAnimatedReaction patterns",
      "Showing audio visualization techniques",
      "Illustrating statistical sampling algorithms",
      "Example of seamless animation continuation"
    ]
  },

  "code_quality": {
    "typescript": {
      "coverage": "Full TypeScript with explicit types",
      "prop_types": ["WaveformScrubberProps", "WaveformScrubberSampleProps"],
      "type_imports": "type keyword for SharedValue imports",
      "function_types": "Explicit return types for helper functions"
    },
    "component_organization": {
      "pattern": "Container/Presentational separation",
      "main_component": "Minimal, delegates to WaveformScrubber",
      "scrubber": "Orchestrates layout and gesture",
      "sample": "Focused, single-responsibility component",
      "hook": "Isolated custom hook for complex logic"
    },
    "helper_functions": {
      "organization": "Separate files in helpers/ directory",
      "exports": "Barrel export via index.ts",
      "documentation": "Extensive comments explaining algorithms",
      "reusability": "Pure functions, easy to test and reuse"
    },
    "constants": {
      "Palette": "Centralized color definitions",
      "waveformSamples": "Pre-calculated at module level",
      "DURATION": "Exported constant for reuse",
      "sampleRate": "Well-documented audio parameters"
    },
    "documentation": {
      "inline_comments": [
        "Detailed explanation of helper function purposes (constants.ts lines 13-18)",
        "Algorithm documentation in pick-n-values-from-array.ts (lines 1-25)",
        "Scale calculation logic explained (waveform-sample/index.tsx lines 20-27)",
        "Hook purpose documented (use-current-playing-value.ts lines 14-23)"
      ],
      "code_clarity": "Self-documenting variable names and structure",
      "type_safety": "Strong typing reduces need for excessive comments"
    },
    "best_practices": [
      "Custom hook for complex logic extraction",
      "memo() for performance-critical components",
      "Worklet directives on all animation functions",
      "Type safety throughout",
      "Separation of concerns (component vs logic vs helpers)",
      "Pure functions for testability"
    ]
  },

  "known_limitations": {
    "fixed_duration": {
      "issue": "DURATION hardcoded to 22 seconds",
      "limitation": "Not configurable per instance",
      "improvement": "Could accept duration as prop"
    },
    "no_audio_playback": {
      "issue": "Visual waveform only, no actual audio",
      "current": "Pure UI component without audio capabilities",
      "enhancement": "Could integrate with react-native-track-player or expo-av"
    },
    "generated_waveform": {
      "issue": "Uses generated sine wave, not real audio data",
      "current": "Synthetic waveform for demonstration",
      "enhancement": "Could extract waveform from actual audio files"
    },
    "single_gesture": {
      "limitation": "Pan gesture only, no tap-to-seek",
      "improvement": "Could add tap gesture for quick position jumps"
    },
    "no_playback_controls": {
      "missing": "Play/pause button, restart, speed controls",
      "current": "Auto-play only",
      "enhancement": "Add standard playback controls"
    },
    "accessibility": {
      "missing": "No accessibility labels or screen reader support",
      "limitation": "Not usable for visually impaired users",
      "improvement": "Add accessibility props and announcements"
    }
  },

  "potential_improvements": {
    "features": [
      "Play/pause toggle button",
      "Tap waveform to jump to position",
      "Playback speed control (0.5x, 1x, 1.5x, 2x)",
      "Loop playback option",
      "Real audio playback integration",
      "Load waveform from audio file",
      "Volume control",
      "Skip forward/backward buttons"
    ],
    "interaction_enhancements": [
      "Haptic feedback on scrub",
      "Long press for precise scrubbing",
      "Double tap to restart",
      "Pinch gesture for zoom in/out on waveform",
      "Velocity-based momentum scrolling"
    ],
    "visual_improvements": [
      "Animated play/pause icon",
      "Waveform color gradient (played vs unplayed)",
      "Loading skeleton while generating waveform",
      "Buffering indicator",
      "Chapter markers",
      "Selection range for loop/trim"
    ],
    "customization": [
      "Configurable colors via props",
      "Adjustable sample count",
      "Custom duration",
      "Configurable animation timings",
      "Theme variants (light/dark)"
    ],
    "accessibility": [
      "AccessibilityLabel for waveform",
      "Screen reader announcements for time",
      "Keyboard controls for playback",
      "Voice control support",
      "High contrast mode",
      "Reduced motion support"
    ],
    "audio_integration": [
      "Connect to expo-av Audio API",
      "Real-time audio analysis",
      "Extract waveform from MP3/WAV files",
      "Streaming audio support",
      "Background playback"
    ]
  },

  "key_insights": {
    "animated_reaction_power": "useAnimatedReaction enables complex gesture-animation coordination without manual state management",
    "seamless_continuation": "Calculating remaining duration enables seamless transition from gesture to automatic playback",
    "retext_performance": "ReText critical for high-frequency text updates without React re-renders",
    "statistical_sampling": "Normal distribution sampling preserves waveform characteristics while reducing complexity",
    "proximity_scaling": "Scaling samples based on distance from playback head creates focus and depth",
    "worklet_optimization": "Keeping all calculations in worklets ensures 60fps performance",
    "gesture_context_separation": "Separate SharedValues for touch and playback positions enable smooth state transitions",
    "memo_critical": "memo() on sample components essential for performance with many animated elements"
  },

  "learning_opportunities": {
    "for_beginners": [
      "Basic pan gesture handling",
      "SharedValue fundamentals",
      "useAnimatedStyle basics",
      "Component composition patterns",
      "Responsive layout with useWindowDimensions"
    ],
    "for_intermediate": [
      "useAnimatedReaction for state watching",
      "Custom hooks with Reanimated",
      "cancelAnimation and animation continuation",
      "useDerivedValue for computed values",
      "ReText for performance optimization",
      "Gesture-animation coordination",
      "Linear easing for constant-speed animations"
    ],
    "for_advanced": [
      "Complex multi-reaction animation systems",
      "Statistical sampling algorithms (Box-Muller transform)",
      "Audio waveform generation from mathematical functions",
      "Array normalization techniques",
      "Remaining time calculation for animation continuation",
      "Performance optimization with memo and worklets",
      "Proximity-based conditional animations",
      "Gesture state to animation state bridging patterns"
    ]
  },

  "related_patterns": {
    "similar_animations": [
      "Video progress bars with scrubbing",
      "Audio spectrum analyzers",
      "Voice recording visualizers",
      "Music equalizer displays",
      "Loading progress with waveform"
    ],
    "interaction_patterns": [
      "Scrubber controls (video/audio)",
      "Timeline editors",
      "Range selectors with visualization",
      "Interactive graphs with pan gesture",
      "Gesture-driven playback controls"
    ],
    "audio_visualizations": [
      "Frequency spectrum displays",
      "Oscilloscope patterns",
      "VU meters",
      "Waveform editors",
      "Sound level indicators"
    ]
  },

  "testing_considerations": {
    "visual_regression": [
      "Waveform renders correctly with 50 samples",
      "Sample heights proportional to normalized values",
      "Active samples visible at full opacity",
      "Inactive samples at 60% opacity",
      "Scaled samples near playback head",
      "Smooth color transitions"
    ],
    "interaction_testing": [
      "Pan gesture updates playback position",
      "Scrubbing cancels automatic playback",
      "Release continues playback from scrubbed position",
      "Current time updates during scrubbing",
      "Samples scale based on proximity to touch",
      "Gesture stays within waveform bounds"
    ],
    "animation_timing": [
      "Full playback completes in exactly 22 seconds",
      "Linear progression (constant speed)",
      "Smooth continuation after scrubbing",
      "No animation jumps or stutters",
      "Sample animations smooth at 60fps"
    ],
    "edge_cases": [
      "Scrubbing to 0:00",
      "Scrubbing to 0:22 (end)",
      "Rapid back-and-forth scrubbing",
      "Quick tap (minimal gesture)",
      "Scrubbing during ongoing animation",
      "Multiple rapid gesture starts/stops"
    ],
    "performance_testing": [
      "60fps during automatic playback",
      "60fps during gesture scrubbing",
      "No memory leaks over extended playback",
      "CPU usage reasonable",
      "Smooth on low-end devices"
    ],
    "mathematical_accuracy": [
      "Time calculation matches position",
      "Remaining time calculation correct",
      "Sample positions evenly distributed",
      "Zero-padding works for all values (0-22)"
    ]
  },

  "accessibility_considerations": {
    "current_state": {
      "screen_readers": "No support",
      "keyboard_navigation": "Not implemented",
      "reduced_motion": "No prefers-reduced-motion support",
      "labels": "No accessibility labels"
    },
    "recommendations": [
      "Add accessibilityRole='adjustable' to waveform",
      "Add accessibilityLabel='Audio playback scrubber'",
      "Add accessibilityValue with current time and duration",
      "Add accessibilityHint='Drag to scrub through audio'",
      "Announce time changes to screen reader",
      "Support accessibilityIncrement/Decrement for keyboard control",
      "Respect prefers-reduced-motion (instant position changes)",
      "Add visible play/pause button for motor-impaired users",
      "Ensure minimum touch target size (44x44pt)",
      "Add alternative text-based time input"
    ]
  },

  "comparison_to_similar_animations": {
    "vs_simple_progress_bar": {
      "this_approach": "Visual waveform with interactive samples",
      "simple_approach": "Basic slider or progress bar",
      "benefit": "Visual representation of audio content, more engaging",
      "cost": "More complex implementation, higher render cost"
    },
    "vs_video_scrubber": {
      "similarity": "Gesture-based position control with time display",
      "difference": "Waveform visualization vs. thumbnail previews",
      "pattern": "Similar gesture coordination patterns apply"
    },
    "vs_soundcloud_player": {
      "similarity": "Interactive waveform with scrubbing",
      "this_implementation": "Custom gesture handling with Reanimated",
      "real_world": "Typically uses web audio API or native audio visualization"
    }
  },

  "historical_context": {
    "waveform_visualization": "Classic audio editing pattern (Pro Tools, Audacity, etc.)",
    "gesture_innovation": "Modern mobile pattern for playback control",
    "technical_approach": "Reanimated + Gesture Handler enable native-feeling interactions",
    "educational_value": "Demonstrates advanced coordination between gesture and animation systems"
  },

  "bundle_size_impact": {
    "code_size": "~350 lines total (main + components + helpers)",
    "dependencies": "Standard React Native animation libraries",
    "runtime_memory": "Minimal - 50 samples, few SharedValues",
    "waveform_data": "~400 bytes for 50 samples",
    "estimated_impact": "< 30KB minified"
  },

  "tags": [
    "audio-player",
    "waveform",
    "scrubber",
    "pan-gesture",
    "animated-reaction",
    "playback-control",
    "reanimated",
    "gesture-handler",
    "audio-visualization",
    "interactive-waveform",
    "retext",
    "linear-animation",
    "gesture-coordination",
    "statistical-sampling",
    "sine-wave-generation",
    "time-display",
    "memo-optimization",
    "worklet-performance"
  ]
}
