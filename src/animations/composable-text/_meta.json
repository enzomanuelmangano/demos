{
  "animation_name": "Composable Text",
  "animation_slug": "composable-text",
  "description": "Character-by-character text animation component that smoothly transitions between different text strings. Each character independently animates in/out with spring physics and scale effects, while layout transitions smoothly rearrange characters.",

  "main_features": [
    "Character-level text animation",
    "Independent enter/exit animations per character",
    "Smooth layout transitions when text changes",
    "Unique key generation for repeated characters",
    "Spring physics for organic motion",
    "Scale + fade entrance effects",
    "Color transition support",
    "Reusable composable component",
    "PressableScale integration"
  ],

  "file_structure": {
    "index.tsx": "Demo screen with toggle interaction",
    "composable-text.tsx": "Core reusable ComposableText component"
  },

  "core_technologies": {
    "animations": "react-native-reanimated",
    "interactions": "pressto",
    "pattern": "Layout animations"
  },

  "packages_and_versions": {
    "react-native-reanimated": {
      "version": "~4.1.1",
      "components": ["Animated.View", "Animated.Text"],
      "layout_animations": [
        "FadeIn",
        "FadeOut",
        "LinearTransition",
        "LayoutAnimationConfig"
      ],
      "hooks": ["useAnimatedStyle"],
      "utilities": ["withTiming"],
      "critical_feature": "Layout animations for declarative character transitions"
    },
    "pressto": {
      "version": "0.3.5-beta.1",
      "component": "PressableScale",
      "usage": "Button with scale press animation and layout transitions"
    }
  },

  "animation_techniques": {
    "character_splitting": {
      "pattern": "Split text string into individual characters",
      "implementation": "text.split('').map((char, index) => ...)",
      "granularity": "One Animated.Text per character",
      "benefit": "Independent animation control per character"
    },
    "entering_animation": {
      "type": "FadeIn",
      "duration": 200,
      "initial_values": {
        "transform": [{ "scale": 0.5 }]
      },
      "spring_config": {
        "mass": 0.3,
        "damping": 12,
        "stiffness": 80
      },
      "effect": "Characters fade in from 50% scale to 100%",
      "trigger": "When character is added to text"
    },
    "exiting_animation": {
      "type": "FadeOut",
      "duration": 200,
      "spring": false,
      "effect": "Characters fade out smoothly",
      "trigger": "When character is removed from text"
    },
    "layout_transition": {
      "type": "LinearTransition",
      "applied_to": ["Individual characters", "Container view"],
      "spring_config": {
        "characters": {
          "mass": 0.3,
          "damping": 12,
          "stiffness": 80
        },
        "container": {
          "mass": 0.4,
          "damping": 12,
          "stiffness": 100
        }
      },
      "effect": "Smooth position/size changes when layout shifts",
      "trigger": "When text length changes, characters reposition"
    },
    "color_transition": {
      "type": "useAnimatedStyle + withTiming",
      "property": "color",
      "duration": 200,
      "implementation": "color: withTiming(text.color, { duration: 200 })",
      "effect": "All characters change color simultaneously"
    }
  },

  "reanimated_layout_animations": {
    "pattern": "Declarative layout animations",
    "philosophy": "Define what should happen, Reanimated handles how",
    "animations_used": {
      "FadeIn": {
        "purpose": "Character entrance",
        "customizations": [
          "duration(200)",
          "withInitialValues({ transform: [{ scale: 0.5 }] })",
          "springify()",
          "mass(0.3)",
          "damping(12)",
          "stiffness(80)"
        ],
        "chaining": "Methods chained for configuration"
      },
      "FadeOut": {
        "purpose": "Character exit",
        "customizations": ["duration(200)"],
        "simplicity": "Simple fade, no scale effect on exit"
      },
      "LinearTransition": {
        "purpose": "Position/size changes",
        "instances": 3,
        "locations": [
          "Each character (different config)",
          "Container view (different config)",
          "PressableScale (different config)"
        ],
        "springify": true,
        "note": "Different spring configs for different elements"
      }
    },
    "LayoutAnimationConfig": {
      "component": "Wrapper component",
      "prop": "skipEntering: true",
      "purpose": "Prevents initial mount animation",
      "effect": "Characters don't animate on first render, only on subsequent changes",
      "scope": "Wraps entire Animated.View"
    }
  },

  "key_generation_strategy": {
    "challenge": "React requires unique keys for list items",
    "problem": "Same character can appear multiple times (e.g., 'o' in 'look')",
    "solution": "Character + occurrence count combination",
    "algorithm": {
      "step_1": "Initialize charCounts object to track occurrences",
      "step_2": "Split text into character array",
      "step_3": "For each character, get current count (default 0)",
      "step_4": "Increment count for that character",
      "step_5": "Create key as '{char}-{count}' (e.g., 'o-0', 'o-1')",
      "example": "'hello' â†’ ['h-0', 'e-0', 'l-0', 'l-1', 'o-0']"
    },
    "memoization": {
      "hook": "useMemo",
      "dependencies": ["text"],
      "benefit": "Recalculates keys only when text changes",
      "critical": true
    },
    "uniqueness_guarantee": "Each character instance has unique key based on position and previous occurrences",
    "animation_stability": "Stable keys prevent unnecessary re-animations"
  },

  "component_architecture": {
    "composable_text": {
      "type": "Reusable component",
      "memo": true,
      "props": {
        "text": {
          "type": "string",
          "required": true,
          "description": "The text to display and animate"
        },
        "style": {
          "type": "StyleProp<TextStyle>",
          "required": false,
          "description": "Style applied to each character"
        },
        "containerStyle": {
          "type": "StyleProp<ViewStyle>",
          "required": false,
          "description": "Style applied to row container"
        }
      },
      "display_name": "ComposableText",
      "flexibility": "Can be used anywhere, not tied to demo"
    },
    "demo_screen": {
      "type": "Example implementation",
      "state": "useState for text variant",
      "variants": {
        "base": {
          "label": "Use Max",
          "color": "rgba(255,255,255,1)"
        },
        "active": {
          "label": "Using Max",
          "color": "rgba(255,255,255,0.5)"
        }
      },
      "interaction": "Toggle between variants on press"
    }
  },

  "react_patterns": {
    "memo": {
      "component": "ComposableText",
      "benefit": "Prevents re-renders when parent re-renders with same props",
      "critical": "Important for performance with many characters"
    },
    "useMemo": {
      "usage": "buildKeys calculation",
      "dependencies": ["text"],
      "prevents": "Recalculating keys on every render",
      "impact": "Medium - keys calculation is relatively cheap but runs for every character"
    },
    "useState": {
      "usage": "Demo screen text variant state",
      "toggle": "Switches between base and active variants"
    },
    "useAnimatedStyle": {
      "usage": "Color transition in demo",
      "dependencies": ["text.color"],
      "returns": "Animated style object with color property"
    },
    "displayName": {
      "value": "ComposableText",
      "purpose": "Better debugging in React DevTools",
      "best_practice": true
    }
  },

  "spring_physics_tuning": {
    "character_entering": {
      "mass": 0.3,
      "damping": 12,
      "stiffness": 80,
      "effect": "Light, bouncy entrance",
      "note": "Lower stiffness = more oscillation"
    },
    "character_layout": {
      "mass": 0.3,
      "damping": 12,
      "stiffness": 80,
      "effect": "Smooth repositioning as text changes",
      "same_as": "entering (consistent feel)"
    },
    "container_layout": {
      "mass": 0.4,
      "damping": 12,
      "stiffness": 100,
      "effect": "Slightly heavier, more stable container movement",
      "difference": "Higher mass and stiffness than characters"
    },
    "pressable_layout": {
      "mass": 0.4,
      "damping": 12,
      "stiffness": 100,
      "effect": "Button size adjusts smoothly when text length changes",
      "same_as": "container (coordinated motion)"
    },
    "philosophy": {
      "damping": "All use 12 (consistent damping across animations)",
      "mass_strategy": "Lighter for characters (0.3), heavier for containers (0.4)",
      "stiffness_strategy": "Lower for characters (80), higher for containers (100)",
      "result": "Characters feel lighter and more playful, containers feel stable"
    }
  },

  "visual_design": {
    "demo_styling": {
      "background": "#0c0c0c (very dark gray)",
      "button_background": "#181818 (dark gray)",
      "text_base_color": "rgba(255,255,255,1) (white)",
      "text_active_color": "rgba(255,255,255,0.5) (50% white)",
      "font_size": 24,
      "font_weight": "bold",
      "border_radius": 32,
      "padding": "16px vertical, 22px horizontal"
    },
    "layout": {
      "container_flex_direction": "row",
      "character_positioning": "Side by side",
      "alignment": "Center of screen",
      "responsive": "Adapts to text length"
    },
    "transition_aesthetics": {
      "entrance": "Pop in from 50% scale with fade",
      "exit": "Simple fade out (no scale)",
      "repositioning": "Smooth spring slide",
      "color_change": "Smooth timing transition"
    }
  },

  "performance_considerations": {
    "character_count_impact": {
      "description": "Performance scales with text length",
      "one_component_per_char": true,
      "recommended_max": "~50 characters for smooth performance",
      "long_text_consideration": "May want to limit for very long strings"
    },
    "memo_benefits": {
      "prevents": "Unnecessary re-renders of ComposableText",
      "important_when": "Parent component re-renders frequently"
    },
    "useMemo_necessity": {
      "buildKeys": "Medium importance - prevents recalculation",
      "cost": "Key generation is O(n) where n = text length"
    },
    "layout_animation_overhead": {
      "description": "Layout animations have some overhead",
      "mitigated_by": "Reanimated's optimized layout animation system",
      "runs_on": "UI thread"
    },
    "skipEntering_optimization": {
      "benefit": "Avoids animating all characters on initial mount",
      "saves": "CPU cycles and provides instant first render"
    }
  },

  "use_cases": {
    "primary": [
      "Button labels that change dynamically",
      "Status indicators with text",
      "Loading states with text changes",
      "Form validation messages",
      "Toggle buttons with state labels"
    ],
    "secondary": [
      "Chat message animations",
      "Score/counter displays with text",
      "Notification badges",
      "Tab labels",
      "Search result counts"
    ],
    "real_world_examples": [
      "iOS/macOS button states",
      "Stripe payment forms",
      "Twitter compose button",
      "Slack message status"
    ],
    "not_recommended_for": [
      "Very long text (> 50 chars)",
      "Rapidly changing text (every frame)",
      "Static text that never changes",
      "Accessibility-critical text that needs instant updates"
    ]
  },

  "comparison_to_alternatives": {
    "vs_text_switch": {
      "traditional": "Replace entire text block",
      "composable_text": "Animate character by character",
      "benefit": "More granular, visually interesting"
    },
    "vs_typed_effect": {
      "typed": "Characters appear sequentially with delay",
      "composable_text": "All changes happen simultaneously, each character independent",
      "use_case": "Different - this is for text replacement, not typing simulation"
    },
    "vs_animated_text": {
      "basic_animated_text": "Entire text fades/scales as one unit",
      "composable_text": "Each character animates independently",
      "visual_quality": "More sophisticated, professional feel"
    }
  },

  "customization_options": {
    "animation_timing": {
      "entering_duration": "Currently 200ms, adjustable",
      "exiting_duration": "Currently 200ms, adjustable",
      "color_duration": "Currently 200ms, adjustable"
    },
    "spring_physics": {
      "mass": "Adjustable per animation type",
      "damping": "Adjustable per animation type",
      "stiffness": "Adjustable per animation type"
    },
    "initial_scale": {
      "current": 0.5,
      "adjustable": "withInitialValues({ transform: [{ scale: X }] })",
      "effect": "Changes how much characters grow on entrance"
    },
    "styling": {
      "text_style": "Fully customizable via style prop",
      "container_style": "Fully customizable via containerStyle prop"
    },
    "skip_entering": {
      "current": true,
      "can_disable": "Remove LayoutAnimationConfig or set to false",
      "effect": "Would animate all characters on initial mount"
    }
  },

  "potential_enhancements": {
    "additional_effects": [
      "Slide in from different directions",
      "Rotation on entrance/exit",
      "Elastic bounce effect",
      "Blur during transition",
      "Color gradient on characters",
      "Stagger delay between characters"
    ],
    "interactivity": [
      "Animate individual characters on hover/press",
      "Different animation per character type (letters vs spaces)",
      "Context-aware animations (add vs remove vs replace)"
    ],
    "performance": [
      "Virtualization for very long text",
      "Configurable animation complexity",
      "Option to disable animations for accessibility"
    ],
    "features": [
      "Character-level styling (different colors per char)",
      "Emoji support optimization",
      "RTL text support",
      "Monospace alignment option"
    ]
  },

  "known_limitations": {
    "character_limit": {
      "issue": "Performance degrades with very long strings",
      "recommendation": "Keep under 50 characters",
      "workaround": "Animate only visible portion of long strings"
    },
    "unicode_considerations": {
      "issue": "split('') may split multi-byte characters incorrectly",
      "affects": "Emoji, some unicode characters",
      "solution": "Could use Array.from(text) or [...text] for proper unicode splitting"
    },
    "accessibility": {
      "issue": "Animation may be distracting for some users",
      "missing": "No prefers-reduced-motion support",
      "recommendation": "Add accessibility considerations"
    },
    "monospace_alignment": {
      "issue": "Characters with different widths cause container width to change",
      "example": "'iii' vs 'WWW' have different widths",
      "workaround": "Use monospace font if consistent width needed"
    },
    "screen_reader": {
      "consideration": "Each character is separate Text component",
      "may_affect": "Screen reader announcement behavior",
      "test": "Should test with screen readers"
    }
  },

  "code_quality": {
    "typescript": "Full TypeScript with explicit types",
    "type_definitions": ["ComposableTextProps"],
    "imports": {
      "types": ["StyleProp", "TextStyle", "ViewStyle"],
      "component_types": true
    },
    "prop_types": {
      "text": "string (required)",
      "style": "StyleProp<TextStyle> (optional)",
      "containerStyle": "StyleProp<ViewStyle> (optional)"
    },
    "naming": {
      "component": "PascalCase",
      "props": "camelCase",
      "constants": "PascalCase (Variants)"
    },
    "documentation": {
      "inline_comments": "Good - explains key generation logic",
      "component_purpose": "Clear from code structure",
      "example_usage": "Provided in demo screen"
    },
    "best_practices": [
      "memo for optimization",
      "useMemo for expensive calculations",
      "displayName for debugging",
      "Type safety with TypeScript",
      "Separated concerns (component vs demo)"
    ]
  },

  "key_insights": {
    "layout_animation_power": "Declarative layout animations are simpler than imperative approaches",
    "key_generation_importance": "Proper key generation is critical for smooth character transitions",
    "character_granularity": "Splitting text into characters enables fine-grained animation control",
    "spring_coordination": "Coordinated spring configs create cohesive visual experience",
    "skipEntering_necessity": "skipEntering prevents unwanted initial animation",
    "component_reusability": "Well-designed component works in any context",
    "independent_animations": "Each character animates independently but feels unified"
  },

  "learning_opportunities": {
    "for_beginners": [
      "Layout animations basics (entering, exiting, layout)",
      "Text manipulation with split('')",
      "React list rendering with keys",
      "useState for simple toggles"
    ],
    "for_intermediate": [
      "Unique key generation for duplicates",
      "Layout animation configuration",
      "Spring physics tuning",
      "useAnimatedStyle for dynamic styles",
      "Component composition patterns"
    ],
    "for_advanced": [
      "Layout animation performance optimization",
      "Creating reusable animated components",
      "Coordinating multiple animation configs",
      "Building animation libraries"
    ]
  },

  "testing_considerations": {
    "unit_tests": [
      "Key generation produces unique keys",
      "Key generation handles empty strings",
      "Key generation handles repeated characters",
      "Component renders with different text lengths"
    ],
    "integration_tests": [
      "Text changes trigger animations",
      "Color transitions work correctly",
      "PressableScale responds to press",
      "Layout adjusts to text length"
    ],
    "visual_tests": [
      "Characters animate smoothly",
      "No layout jumps or flickers",
      "Spring animations feel natural",
      "Colors transition smoothly"
    ],
    "accessibility_tests": [
      "Screen reader announces text correctly",
      "Animation doesn't prevent text reading",
      "Respects reduced motion preferences (if implemented)"
    ],
    "edge_cases": [
      "Empty string",
      "Single character",
      "Very long string (100+ chars)",
      "Special characters (!@#$%)",
      "Emoji",
      "Repeated characters (aaaaaa)",
      "Rapid toggling"
    ]
  },

  "bundle_size_impact": {
    "component_size": "Very small (~66 lines including demo)",
    "dependencies": "Reanimated and pressto (likely already in project)",
    "runtime_overhead": "Minimal - one component per character",
    "estimated_size": "< 2KB"
  },

  "accessibility_recommendations": {
    "current_state": "No accessibility considerations implemented",
    "should_add": [
      "Respect prefers-reduced-motion",
      "Accessible label for entire text",
      "ARIA attributes if needed",
      "Test with screen readers"
    ],
    "implementation": {
      "reduced_motion": "Disable animations when AccessibilityInfo.isReduceMotionEnabled",
      "screen_reader": "Consider using accessibilityLabel on container",
      "focus": "Ensure proper focus behavior"
    }
  },

  "related_patterns": {
    "animated_text_input": "Similar character-level animations for input",
    "typing_animation": "Sequential character appearance",
    "text_reveal": "Characters reveal from mask",
    "text_scramble": "Random character replacement effect",
    "ticker_text": "Scrolling number/text animations"
  },

  "real_world_inspiration": {
    "ios_buttons": "iOS system buttons with state changes",
    "stripe_ui": "Stripe payment button states",
    "notion": "Notion button state transitions",
    "linear_app": "Linear's smooth UI transitions"
  },

  "tags": [
    "text-animation",
    "layout-animations",
    "reanimated",
    "character-animation",
    "spring-physics",
    "fade-in",
    "fade-out",
    "button-states",
    "composable",
    "reusable-component",
    "ui-transitions"
  ]
}
